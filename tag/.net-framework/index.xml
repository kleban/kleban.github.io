<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.net framework | kleban.page</title>
    <link>/tag/.net-framework/</link>
      <atom:link href="/tag/.net-framework/index.xml" rel="self" type="application/rss+xml" />
    <description>.net framework</description>
    <generator>Wowchemy (https://wowchemy.com)</generator><language>uk</language><copyright>© 2021 Yurii Kleban</copyright><lastBuildDate>Sat, 17 Apr 2021 00:00:00 +0100</lastBuildDate>
    <image>
      <url>/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png</url>
      <title>.net framework</title>
      <link>/tag/.net-framework/</link>
    </image>
    
    <item>
      <title>Лекція 3. Основи роботи з Visual Studio та платформою .NET</title>
      <link>/courses/csharp-basics/lecture3/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0100</pubDate>
      <guid>/courses/csharp-basics/lecture3/</guid>
      <description>&lt;hr&gt;
&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#31коротка-характеристика-та-історія-розвитку-середовища-розробки-visual-studio&#34;&gt;3.1	Коротка характеристика та історія розвитку середовища розробки Visual Studio.&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#контрольні-запитання&#34;&gt;Контрольні запитання&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#список-використаних-джерел&#34;&gt;Список використаних джерел&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#додаткові-матеріали-для-завнатаження&#34;&gt;Додаткові матеріали для завнатаження&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Розділ у процесі наповнення.
  &lt;/div&gt;
&lt;/div&gt;
&lt;h2 id=&#34;31коротка-характеристика-та-історія-розвитку-середовища-розробки-visual-studio&#34;&gt;3.1	Коротка характеристика та історія розвитку середовища розробки Visual Studio.&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Microsoft Visual Studio&lt;/code&gt;&lt;/strong&gt; - лінійка продуктів компанії Майкрософт, що включають інтегроване середовище розробки програмного забезпечення і ряд інших інструментальних засобів.&lt;/p&gt;
&lt;p&gt;Середовище розробки &lt;code&gt;Visual Studio&lt;/code&gt; представляє собою повний набір інструментів для створення як настільних додатків, так і корпоративних веб-додатків для спільної роботи груп. Використовуючи ефективні інструменти розробки &lt;code&gt;Visual Studio&lt;/code&gt;, засновані на використанні компонентів, та інші технології, можна не тільки створювати ефективно працюючі настільні додатки, але і спрощувати спільне проектування, розробку і розгортання корпоративних рішень.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Visual Studio&lt;/code&gt; включає один або декілька компонентів з наступних:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Visual Basic .NET&lt;/code&gt;, а до його появи - &lt;code&gt;Visual Basic&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visual C++&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visual C#&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Visual F#&lt;/code&gt; (включений у &lt;code&gt;Visual Studio 2010&lt;/code&gt;).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Багато варіантів поставки також включають	&lt;code&gt;Microsoft SQL Server&lt;/code&gt; або &lt;code&gt;Microsoft SQL Server Express&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;На сьогодні &lt;code&gt;Visual Studio&lt;/code&gt; уже підтримує досить велику кількість мов програмування та фреймворків не лише зі стеку &lt;code&gt;.NET&lt;/code&gt;-технологій.&lt;/p&gt;
&lt;p&gt;Опишемо коротко найважливіші версії &lt;code&gt;IDE Visual Studio&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Visual Studio 97&lt;/code&gt; - перша випущена версія &lt;code&gt;Visual Studio&lt;/code&gt;, у ній вперше були зібрані разом різні засоби розробки ПЗ. Вона була випущена в двох версіях &lt;code&gt;Professional&lt;/code&gt; та &lt;code&gt;Enterprise&lt;/code&gt;. Вона включала в себе &lt;code&gt;Visual Basic 5.0&lt;/code&gt;, &lt;code&gt;Visual C++ 5.0&lt;/code&gt;, &lt;code&gt;Visual J++ 1.1&lt;/code&gt;, &lt;code&gt;Visual FoxPro 5.0&lt;/code&gt;, вперше з&amp;rsquo;явилося середовище розробки &lt;code&gt;ASP - Visual InterDev&lt;/code&gt;. &lt;code&gt;Visual Studio 97&lt;/code&gt; - була першою спробою &lt;code&gt;Microsoft&lt;/code&gt; створити єдине середовище для розробки на різних мовах програмування: &lt;code&gt;Visual C++&lt;/code&gt;, &lt;code&gt;Visual J++&lt;/code&gt;, &lt;code&gt;Visual InterDev&lt;/code&gt;, і MSDN використовували одне середовище, так зване &lt;code&gt;Developer Studio&lt;/code&gt;. &lt;code&gt;Visual Basic&lt;/code&gt; і &lt;code&gt;Visual FoxPro&lt;/code&gt; використовували окремі середовища для розробки.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Visual Studio. NET&lt;/code&gt; (кодове ім&amp;rsquo;я &lt;code&gt;Rainier&lt;/code&gt;; внутрішня версія 7.0) - випущена в лютому 2002 (включає &lt;code&gt;.NET Framework 1.0&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Visual Studio. NET 2003&lt;/code&gt; (кодове ім&amp;rsquo;я &lt;code&gt;Everett&lt;/code&gt;; внутрішня версія 7.1) - випущена в квітні 2003 (включає &lt;code&gt;.NET Framework 1.1&lt;/code&gt;).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Visual Studio 2005&lt;/code&gt; (кодове ім&amp;rsquo;я &lt;code&gt;Whidbey&lt;/code&gt;; внутрішня версія 8.0) - випущена в кінці жовтня 2005, остання що офіційно працює на &lt;code&gt;Windows 2000&lt;/code&gt;, (включає &lt;code&gt;.NET Framework 2.0&lt;/code&gt;). На початку листопада 2005 також вийшла серія продуктів в редакції &lt;code&gt;Express&lt;/code&gt;: &lt;code&gt;Visual C++ 2005 Express&lt;/code&gt;, &lt;code&gt;Visual Basic 2005 Express&lt;/code&gt;, &lt;code&gt;Visual C # 2005 Express&lt;/code&gt; і ін. 19 квітня 2006 редакція &lt;code&gt;Express&lt;/code&gt; стала безкоштовною.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Visual Studio 2008&lt;/code&gt; (кодове ім&amp;rsquo;я &lt;code&gt;Orcas&lt;/code&gt;) - випущена 19 листопада 2007, одночасно з . &lt;code&gt;NET Framework 3.5&lt;/code&gt;. Націлена на створення додатків для ОС &lt;code&gt;Windows Vista&lt;/code&gt; (але підтримує і &lt;code&gt;XP&lt;/code&gt;), &lt;code&gt;Office 2007&lt;/code&gt; та веб-додатків. Включає в себе &lt;code&gt;LINQ&lt;/code&gt;, нові версії мов &lt;code&gt;C#&lt;/code&gt; і &lt;code&gt;Visual Basic&lt;/code&gt;. До студії не увійшов &lt;code&gt;Visual J#&lt;/code&gt;. З 28 жовтня 2008 вперше доступна версія російською мовою.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Visual Studio 2010&lt;/code&gt; (кодове ім&amp;rsquo;я &lt;code&gt;Hawaii&lt;/code&gt;, для &lt;code&gt;Ultimate&lt;/code&gt; - &lt;code&gt;Rosario&lt;/code&gt;) - випущена 12 квітня 2010 разом з &lt;code&gt;.NET Framework 4.0&lt;/code&gt;. &lt;code&gt;Visual Studio&lt;/code&gt; включає підтримку мов &lt;code&gt;C# 4.0&lt;/code&gt; і &lt;code&gt;Visual Basic. NET 10.0&lt;/code&gt;, а також мову &lt;code&gt;F#&lt;/code&gt;, яка була відсутня в попередніх версіях.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-question-circle fa-2x text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;контрольні-запитання&#34;&gt;Контрольні запитання&lt;/h2&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-book fa-2x text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;список-використаних-джерел&#34;&gt;Список використаних джерел&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ada Lovelace on Wikipedia. Url: &lt;a href=&#34;https://en.wikipedia.org/wiki/Ada_Lovelace&#34;&gt;https://en.wikipedia.org/wiki/Ada_Lovelace&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DiagramDesigner. Url: &lt;a href=&#34;https://logicnet.dk/DiagramDesigner/&#34;&gt;https://logicnet.dk/DiagramDesigner/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Draw.IO. Url: &lt;a href=&#34;https://www.diagrams.net/&#34;&gt;https://www.diagrams.net/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Albahari, J., &amp;amp; Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cardelli, L., &amp;amp; Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з &lt;a href=&#34;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&#34;&gt;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MSDN. (без дати). Отримано з Microsoft Developer Network: &lt;a href=&#34;http://msdn.microsoft.com/&#34;&gt;http://msdn.microsoft.com/&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Биллиг, А. (2005). Основы программирования на C#. Москва, Россия: НОУ ИНТУИТ.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Нейгел, К. И. (2011). С# 4.0 и платформа .NET 4 для профессионалов. Москва, Россия: ООО &amp;ldquo;И.Д. Вильямс&amp;rdquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Павловская, Т. (2009). С#. Программирование на языке высокого уровня. Учебник для вузов. СПб, Россия: Питер.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!--
---


  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
## Задачі
--&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-download fa-2x  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;додаткові-матеріали-для-завнатаження&#34;&gt;Додаткові матеріали для завнатаження&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі DOCX &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-word  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі PDF &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-pdf  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;Діаграми до лекції у форматі &lt;code&gt;
  &lt;i class=&#34;fas fa-project-diagram  pr-1 fa-fw&#34;&gt;&lt;/i&gt;draw.io&lt;/code&gt; на &lt;code&gt;
  &lt;i class=&#34;fab fa-github  pr-1 fa-fw&#34;&gt;&lt;/i&gt;github&lt;/code&gt; &lt;a href=&#34;https://github.com/kleban/csharp-basics-public/tree/master/diagrams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Перейти&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Лекція 4. Типи даних та змінні у .NET</title>
      <link>/courses/csharp-basics/lecture4/</link>
      <pubDate>Fri, 09 Apr 2021 00:00:00 +0100</pubDate>
      <guid>/courses/csharp-basics/lecture4/</guid>
      <description>&lt;hr&gt;
&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter41&#34;&gt;4.1. Поняття типу даних. Система типів .NET.&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter42&#34;&gt;4.2. Оголошення та ініціалізація змінних. Константи&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter43&#34;&gt;4.3. Оператори та вирази&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter431&#34;&gt;4.3.1. Арифметичні оператори&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter432&#34;&gt;4.3.2. Інкремент і декремент&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter433&#34;&gt;4.3.3. Логічні оператори. Оператори відношення&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter434&#34;&gt;4.3.4. Інші оператори&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter44&#34;&gt;4.4. Літерали&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter441&#34;&gt;4.4.1. Арифметичні літерали&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter442&#34;&gt;4.4.2. Логічні літерали&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter443&#34;&gt;4.4.3. Символьні літерали&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter45&#34;&gt;4.5. Приведення типів даних&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter46&#34;&gt;4.6. Робота з памяттю у С#&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter461&#34;&gt;4.6.1. &amp;ldquo;Стек&amp;rdquo; і &amp;ldquo;купа&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter462&#34;&gt;4.6.2. Типи-посилання та типи-значення&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4t&#34;&gt;Задачі&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4c&#34;&gt;Контрольні запитання&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4s&#34;&gt;Список використаних джерел&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4a&#34;&gt;Додаткові матеріали для завантаження&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter41&#34;&gt;4.1. Поняття типу даних. Система типів .NET.&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Тип&lt;/strong&gt; &lt;em&gt;(загальне поняття)&lt;/em&gt; — це стійка сукупність елементів зі
спільними характеристиками, яку можна виділити серед множини інших
об’єктів.&lt;/p&gt;
&lt;p&gt;Тип даних як у математиці, так і у програмуванні має обмеження
на значення, що дозволяє зменшити невизначеність у записах та
уникнути частини помилок. Тип даних вказує яким чином об’єкти цього
типу можуть взаємодіяти з іншими елементами мови програмування або
між собою (Джерело: Cardelli &amp;amp; Wegner, 1985).&lt;/p&gt;
&lt;p&gt;Системи типів у мовах програмування мають ряд властивостей
та діляться за різними класифікаціями: статичні і динамічні, строго
типізовані і не строго типізовані тощо. Також на сьогодні існують
елементи мов програмування, що перемішують дані поняття або
підміняють їх (наприклад &lt;code&gt;var&lt;/code&gt; у &lt;code&gt;C#&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Система типів &lt;code&gt;.NET&lt;/code&gt; називається &lt;strong&gt;&lt;code&gt;Common Type System&lt;/code&gt;&lt;/strong&gt; (далі &lt;code&gt;CTS&lt;/code&gt;).
CTS визначає спосіб оголошення використання та керування типами у
середовищі &lt;code&gt;CLR&lt;/code&gt;, а також є важливою частиною підтримки міжмовної
інтеграції у середовищі виконання (MSDN, n.d.).&lt;/p&gt;
&lt;p&gt;Усі типи на платформі &lt;code&gt;.NET Framework&lt;/code&gt; поділяються на типи-значення (&lt;code&gt;Value Type&lt;/code&gt;) та типи-посилання (&lt;code&gt;Rerence Type&lt;/code&gt;). Типи-значення представлені фактичними
значеннями об’єкта, тобто під час присвоєння змінної відбувається
створення нової копії об’єкта. Для типів посилань створення нової копії
не відбувається. Типи посилання вказують на «комірку пам’яті» де
розміщено значення.&lt;/p&gt;
&lt;p&gt;У спрощеному вигляді система типів .NET має такий вигляд:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; типи-значення:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;прості типи;&lt;/li&gt;
&lt;li&gt;структури;&lt;/li&gt;
&lt;li&gt;перелічувані типи;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; типи-посилання:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;класи;&lt;/li&gt;
&lt;li&gt;інтерфейси;&lt;/li&gt;
&lt;li&gt;масиви;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;center&gt;


















&lt;figure id=&#34;figure-рис-41-система-типів-net&#34;&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;/media/courses/csharp-basics/svg/lecture-4-types.svg&#34; data-caption=&#34;Рис. 4.1. Система типів .NET&#34;&gt;


  &lt;img src=&#34;/media/courses/csharp-basics/svg/lecture-4-types.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Рис. 4.1. Система типів .NET
  &lt;/figcaption&gt;


&lt;/figure&gt;
 
&lt;/center&gt;
&lt;p&gt;Варто також згадати, що типи даних, які підтримуються
компілятором напряму і знаходяться у &lt;code&gt;.NET Framework Class Library&lt;/code&gt;
(&lt;code&gt;FCL&lt;/code&gt;) називаються примітивними. Оскільки типи повинні бути
універсальними між різними мовами, то розрізняються &lt;code&gt;FCL&lt;/code&gt; типи та типи
конкретної мови програмування (Також варто відмітити, що існує загальномовна специфікація типів (&lt;code&gt;Common Language Specification&lt;/code&gt;), проте відповідність
їй не обов’язкова). По суті типи конкретної мови
програмування є псевдонімами &lt;code&gt;FCL&lt;/code&gt; типів. Наприлад, &lt;code&gt;int&lt;/code&gt; у C# — це Int32
у FCL, проте записати можна обидва варіанти:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int a = 0;
Int32 b = 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Розглянемо примітивні типи даних C# та їх відмінності
(табл. 4.1).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.1. Примітивні типи C# та їх характеристики (Биллиг, 2005)&lt;/em&gt;&lt;/p&gt;
&lt;table class=&#34;table table-bordered&#34; style=&#34;width:100%&#34;&gt;
  &lt;tr&gt;
    &lt;th colspan=4&gt;&lt;center&gt;Цілочисельні типи&lt;/center&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th style=&#34;width: 25%&#34;&gt;Назва&lt;/th&gt;
    &lt;th style=&#34;width: 25%&#34;&gt;FLC-тип&lt;/th&gt;
    &lt;th style=&#34;width: 30%&#34;&gt;Значення&lt;/th&gt;
    &lt;th style=&#34;width: 20%&#34;&gt;Розмір, біт&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;sbyte &lt;/td&gt;
    &lt;td&gt;System.SByte &lt;/td&gt;
    &lt;td&gt;$$[-128;127]$$&lt;/td&gt;
    &lt;td&gt;8&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;byte&lt;/td&gt;&lt;td&gt;System.Byte&lt;/td&gt;&lt;td&gt;$$[0;255]$$&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;short&lt;/td&gt;&lt;td&gt; System.Short&lt;/td&gt;&lt;td&gt;$$[-32768;32767]$$&lt;/td&gt;&lt;td&gt; 16&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;ushort&lt;/td&gt;&lt;td&gt; System.UShort&lt;/td&gt;&lt;td&gt;$$[0;65535]$$&lt;/td&gt;&lt;td&gt; 16&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;int&lt;/td&gt;&lt;td&gt; System.Int32&lt;/td&gt;&lt;td&gt;$$≈(-2*10^9;2*10^9)$$&lt;/td&gt;&lt;td&gt; 32&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;uint&lt;/td&gt;&lt;td&gt; System.UInt32&lt;/td&gt;&lt;td&gt;$$≈(0;4*10^9)$$&lt;/td&gt;&lt;td&gt; 32&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;long&lt;/td&gt;&lt;td&gt; System.Int64&lt;/td&gt;&lt;td&gt;$$≈(-9*10^{18};9*10^{18})$$&lt;/td&gt;&lt;td&gt; 64&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;ulong&lt;/td&gt;&lt;td&gt; System.UInt64&lt;/td&gt;&lt;td&gt;$$≈(0;18*10^{18})$$&lt;/td&gt;&lt;td&gt;64&lt;/td&gt;&lt;/tr&gt;
  &lt;tr&gt;
    &lt;th colspan=4&gt;&lt;center&gt;Числові типи з дробовою частиною&lt;/center&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th style=&#34;width: 25%&#34;&gt;Назва&lt;/th&gt;
    &lt;th style=&#34;width: 25%&#34;&gt;FLC-тип&lt;/th&gt;
    &lt;th style=&#34;width: 30%&#34;&gt;Значення&lt;/th&gt;
    &lt;th style=&#34;width: 20%&#34;&gt;Точність, знаків після коми&lt;/th&gt;
  &lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;float&lt;/td&gt;&lt;td&gt;System.Single&lt;/td&gt;&lt;td&gt;$$≈(+1.5*10^{-45}; +3.4*10^{38})$$&lt;/td&gt;&lt;td&gt;7&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;double&lt;/td&gt;&lt;td&gt;System.Double&lt;/td&gt;&lt;td&gt;$$≈(+5.0*10^{-324}; +1.7*10^{308})$$&lt;/td&gt;&lt;td&gt;15-16&lt;/td&gt;&lt;/tr&gt;
 &lt;tr&gt;&lt;td&gt;decimal&lt;/td&gt;&lt;td&gt;System.Decimal&lt;/td&gt;&lt;td&gt;$$≈(+1.0*10^{-28}; +7.9*10^{28})$$&lt;/td&gt;&lt;td&gt;28-29&lt;/td&gt;&lt;/tr&gt;
   &lt;tr&gt;
    &lt;th colspan=4&gt;&lt;center&gt;Логічний тип&lt;/center&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Назва&lt;/th&gt;
    &lt;th&gt;FLC-тип&lt;/th&gt;
    &lt;th&gt;Значення&lt;/th&gt;
    &lt;th&gt;Розмір, біт&lt;/th&gt;
  &lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;bool&lt;/td&gt;&lt;td&gt;System.Boolean&lt;/td&gt;&lt;td&gt;true/false&lt;/td&gt;&lt;td&gt;8&lt;/td&gt;&lt;/tr&gt;
      &lt;tr&gt;
    &lt;th colspan=4&gt;&lt;center&gt;Символи та рядки&lt;/center&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Назва&lt;/th&gt;
    &lt;th&gt;FLC-тип&lt;/th&gt;
    &lt;th&gt;Значення&lt;/th&gt;
    &lt;th&gt;Розмір, біт&lt;/th&gt;
  &lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;char&lt;/td&gt;&lt;td&gt;System.Char&lt;/td&gt;&lt;td&gt;U+0000 - U+ffff&lt;/td&gt;&lt;td&gt;16&lt;/td&gt;&lt;/tr&gt;
     &lt;tr&gt;&lt;td&gt;string&lt;/td&gt;&lt;td&gt;System.String&lt;/td&gt;&lt;td colspan=2&gt;Рядок символів Unicode&lt;/td&gt;&lt;/tr&gt;
        &lt;tr&gt;
    &lt;th colspan=4&gt;&lt;center&gt;Об&#39;єктний тип&lt;/center&gt;&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;th&gt;Назва&lt;/th&gt;
    &lt;th&gt;FLC-тип&lt;/th&gt;
    &lt;th colspan=2&gt;Притмітки&lt;/th&gt;
  &lt;/tr&gt;
   &lt;tr&gt;&lt;td&gt;object&lt;/td&gt;&lt;td&gt;System.Object&lt;/td&gt;&lt;td colspan=2&gt;Базовий тип для усіх інших&lt;/td&gt;&lt;/tr&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;p&gt;Розглянемо коротко структури, класи та перелічувані типи даних.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Структури.&lt;/strong&gt; Структура є першим визначеним користувачем
типом, який ми розглянемо. Схожі &lt;code&gt;UDT&lt;/code&gt; (&lt;code&gt;User Defined Types&lt;/code&gt;) є і у мовах
&lt;code&gt;Pascal&lt;/code&gt;, &lt;code&gt;C&lt;/code&gt; тощо. По суті структури у C# є спрощеною версією класів із
мінімальними відмінностями та наслідуєть не напряму від &lt;code&gt;System.Object&lt;/code&gt;,
а від &lt;code&gt;System.ValueType&lt;/code&gt;. Структури в С# створюються за допомогою
ключового слова &lt;strong&gt;&lt;code&gt;struct&lt;/code&gt;&lt;/strong&gt; (Лістинг 4.1).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.1. Структура &lt;code&gt;Point&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{csharp,&#34;&gt;public struct Point
{
    // Поле структури
    public int x, y;
  
    //Параметризований конструктор
    public Point(int xPosition, int yPosition) {
        x = xPosition;
        y = yPosition;
    }
    
    //Метод структури
    public void Display() {
        System.Console.WriteLine(&amp;quot;({0}, {1})&amp;quot;, x, y);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Класи.&lt;/strong&gt; Клас є посилальним типом даних, що неявно
наслідується від &lt;code&gt;System.Object&lt;/code&gt;. У класі оголошуються поля, методи,
властивості, конструктори, події та інші елементи, що визначають його
дані та можливості. Оголошення класу відбувається із використанням
ключовго слова class (лістинг 4.2).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.2. Клас &lt;code&gt;Student&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-{csharp}&#34;&gt;public class Student
{
    private int _age;
    public int GetAge() 
    {
      return _age;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Перелічувані типи.&lt;/strong&gt; Перелічуваний тип (&lt;code&gt;enum) – це програмна конструкція, що дозволяє у межах типу даних визначити альтернативні значення для базового примітивного типу. Перелічувані типи наслідують напряму &lt;/code&gt;System.Enum`. Перелічувані типи мають значні обмеження у
можливостях порівняно з класами або структурами. Оголошення
перелічуваного типу даних відбувається за допомогою ключового слова
enum (лістинг 4.3).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.3. Перелічуваний тип &lt;code&gt;Character&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public enum Character
{
    Student = 0,
    Teacher = 1,
    Dekan = 2,
    Rector = 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Розглянемо відмінності між типами-посиланнями та типами
значеннями (Albahari &amp;amp; Albahari, 2012). &lt;em&gt;Примітка. Детальніша інформація про значимі та посилальні типи даних подана у &lt;a href=&#34;#chapter46&#34;&gt;питанні 4.6&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.2. Порівняння типів-значень та типів-посилань у C#&lt;/em&gt;&lt;/p&gt;
&lt;table style=&#34;width:100%&#34;&gt;
  &lt;tr&gt;&lt;td&gt;1&lt;/td&gt;&lt;th style=&#34;width:50%&#34;&gt;&lt;center&gt;Тип-значення&lt;/center&gt;&lt;/th&gt;
  &lt;th style=&#34;width:50%&#34;&gt;&lt;center&gt;Тип-посилання&lt;/center&gt;&lt;/th&gt;&lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;
&lt;pre&gt;
public &lt;b&gt;struct&lt;/b&gt; Point
{
    public int X { get;set; }
    public int Y { get;set; }
}
&lt;/pre&gt;
    &lt;/td&gt;
        &lt;td&gt;
&lt;pre&gt;
public &lt;b&gt;class&lt;/b&gt; Point
{
    public int X { get;set; }
    public int Y { get;set; }
}
&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;3&lt;/td&gt;
  &lt;td colspan=2&gt;
  &lt;pre&gt;
var p1 = new Point { X = 5, Y = 7 };
var p2 = p1;
p2.X = 10;
Console.WriteLine(&#34;p1: X = {0}&#34;, p1.X);
Console.WriteLine(&#34;p2: X = {0}&#34;, p2.X);
  &lt;/pre&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;&lt;td&gt;4&lt;/td&gt;
    &lt;td&gt;
&lt;pre&gt;
p1: X = 5
p2: X = 10
&lt;/pre&gt;
    &lt;/td&gt;
        &lt;td&gt;
&lt;pre&gt;
p1: X = 10
p2: X = 10
&lt;/pre&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
  &lt;td&gt;5&lt;/td&gt;
  &lt;td&gt;&lt;div class=&#34;mermaid&#34;&gt;
graph TD;
  p1--&gt;X1[X=5];
  p1--&gt;Y1[Y=7];
  p2--&gt;X2[X=10];
  p2--&gt;Y2[Y=7];
&lt;/div&gt;&lt;/td&gt;
  &lt;td&gt;&lt;div class=&#34;mermaid&#34;&gt;
graph TD;
  p1--&gt;REF[object_ref];
  p2--&gt;REF[object_ref];
  REF--&gt;X3[X=10];
  REF--&gt;Y3[Y=7];
&lt;/div&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
&lt;p&gt;Як видно із табл. 4.2 тип-значення створює копію елемента у
пам’яті і працює з копією, не впливаючи на початкові дані. Тип-посилання вказує на ділянку пам’яті і під час зміни значення поля впливає на усі об’єкти, що «прив’язані» до цієї змінної.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter42&#34;&gt;4.2. Оголошення та ініціалізація змінних. Константи&lt;/h2&gt;
&lt;p&gt;Змінна у програмуванні є по суті назвою, що вказує на деякий
об’єкт у пам’яті. Також можна сказати, що змінна вказує на адресу у
пам’яті і надає доступ до значення, що знаходиться за цією адресою.&lt;/p&gt;
&lt;p&gt;Для оголошення змінної використовується запис у вигляді:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;тип ім’я_змінної;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Правила іменування змінних у C#:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ім’я змінної може починатися із латинської букви або
знаку «_».&lt;/li&gt;
&lt;li&gt;Ім’я змінної може складатися із латинських букв, цифр
або знаку «_».&lt;/li&gt;
&lt;li&gt;Якщо ім’я змінної співпадає із ключовим словом мови
програмування, то потрібне використовувати його із
знаком @ (Наприклад: &lt;code&gt;int @class = 1;&lt;/code&gt; ).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.4. Приклад оголошення змінних у C#.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int a;
  float myNumber;
  double _salary;
  string name;
  bool isPresent;
  decimal discount;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Під час оголошення змінної створюється екземпляр вказаного
типу. Таким чином, можна сказати, що можливості конкретної змінної
визначаються можливостями типу даних. Наприклад, у змінну
цілочисельного типу не можна записати рядок (&lt;code&gt;string&lt;/code&gt;). Також важливо
відмітити, що у C# не можна змінити тип даних під час існування змінної.
До того як змінна буде використана у коді програми вона повинна
бути оголошеною. Компілятор перевіряє наявність оголошення змінної у
момент її використання.&lt;/p&gt;
&lt;p&gt;Будь-яка змінна до використання повинна бути ініціалізованою.
Ініціалізація змінних – процес виділення у «пам’яті» під конкретний тип
даних із записом значення. Також ініціалізацію змінних можна пояснити
як надання конкретного значення змінній (лістинг 4.5).&lt;/p&gt;
&lt;p&gt;Ініціалізацію змінної можна провести одразу під час оголошення
або у процесі виконання програми (динамічна ініціалізація). Синтаксис
ініціалізації змінної під час оголошення:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;тип ім’я_зміннної = значення;&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Оператор &lt;strong&gt;&lt;code&gt;=&lt;/code&gt;&lt;/strong&gt; у записі означає «присвоїти». «Дорівнює»
записується як &lt;strong&gt;&lt;code&gt;==&lt;/code&gt;&lt;/strong&gt; і є оператором відношення.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.5. Ініціалізація змінних.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int a = 10;
  float myNumber = 0.2;
  double _salary = 100.9;
  string name = &amp;quot;Ivan&amp;quot;;
  bool isPresent = true;
  decimal discount = 0.02;
  char c = &#39;R&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Під час оголошення двох і більше змінних однакового типу даних
списком (розділення комами) можна здійснювати вибіркове присвоєння
значень (лістинг 4.6).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.6. Оголошення та ініціалізація змінних.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int a = 10, b, c = 20;
  char d, f = &#39;F&#39;, s = &#39;3&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Динамічна ініціалізація змінних передбачає присвоєння значення
у процесі виконання програми, наприклад, за результатами обчислень
(лістинг 4.7).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.7. Динамічна ініціалізація змінних.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  double a = 5, b = 7; //Катети
  double c; // гіпотенуза
  c = Math.Sqrt(a * a + b * b);
  Console.WriteLine(&amp;quot;Гіпотенуза дорівнює - {0:F}&amp;quot;, c);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У C# є можливість оголошення та ініціалізації констант.
&lt;code&gt;Константа&lt;/code&gt; у математиці є величиною, значення якої не
змінюється. Константа є протиставленням до змінної. У програмуванні
&lt;code&gt;константа&lt;/code&gt; – це спосіб запису інформації, зміна якої заборонена. Значення
констати повинно бути відомим у момент компіляції програми. По суті
константу потрібно ініціалізувати у момент оголошення (лістинг 4.8).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.8. Оголошення та ініціалізація констант.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  const string spec = &amp;quot;економічна кібернетика&#39;;
  const double PI = 3.14;
  const bool Truth = true;
  43 з 111
  const char _iSymbol = &#39;i&#39;;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Область видимості та час існування змінної.&lt;/strong&gt; Усі змінні до цього
часу ми оголошували у межах функції &lt;code&gt;Main()&lt;/code&gt;. Насправді змінна може
бути оголошеною у межах різних блоків програми. Блоки програми
відкремлються «фігурними» дужками (&lt;code&gt;{}&lt;/code&gt;). Блок коду визначає область
видимості та час існування змінної. За межами цього блоку змінної не
існує і доступу до неї немає. Розглянемо приклад коду (лістинг 4.9).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.9. Область видимості змінної.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;static void Main(string[] args)
{
   int x; // Змінна відома у межах метода Main()
   x = 10;
   if (x == 10)
   {
     // Початок нової області видимості
     int у = 20; // Змінна відома лише цьому блоку
     Console.WriteLine(&amp;quot;х та у: &amp;quot; + x + &amp;quot; &amp;quot; + у);
     x = у * 2;
   }
   // y = 100; //- помилка &amp;quot;y&amp;quot; - не існує
   Console.WriteLine(&amp;quot;х : &amp;quot; + x);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Якщо видалити коментування у рядку &lt;code&gt;y = 100&lt;/code&gt;, то компілятор
проінформує про помилку &lt;code&gt;~ «Змінна ‘y’ не існує у даному контексті»&lt;/code&gt;,
тобто вона поза областю видимості і доступу немає.&lt;/p&gt;
&lt;p&gt;Зміні створюються у момент входження у область видимості і
видаляються у момент виходу з неї. Таким чином можна зрозуміти, що
повторне входження у область видимості створює змінну із початковим
значенням повторно і не зберігає значення між викликами (лістинг 4.10).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.10. Область видимості змінних.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int x = 10;
  
  if (x == 10) {
     x = x + 1;
     int a = x;
  }
  
  if (x == 11) {
     x = x + 1;
     int a = x;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;З прикладу лістингу 4.10. видно, що змінна a оголошена двічі,
проте в різних областях видимості. У таком випадку помилки компіляції
не буде. Отже, час існування змінної визначається областю її видимості.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter43&#34;&gt;4.3. Оператори та вирази&lt;/h2&gt;
&lt;p&gt;У С# передбачений широкий набір операторів, які дають в руки програмістові потужні важелі
управління при створенні всіляких виразів і їх обчисленні. У С# є чотири загальні класи операторів:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; арифметичні;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; порозрядні;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; логічні;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; оператори відношення.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;chapter431&#34;&gt;4.3.1. Арифметичні оператори&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.3. Арифметичні оператори&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Оператор&lt;/th&gt;
&lt;th&gt;Дія&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;+&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Додавання&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;-&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Віднімання, унарний мінус&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;b&gt;&lt;code&gt;*&lt;/code&gt;&lt;/b&gt;&lt;/td&gt;
&lt;td&gt;Множення&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;/&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Ділення&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;%&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Ділення по модулю&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;--&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Декремент&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;++&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Інкремент&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Дія С#-операторів &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt; і &lt;code&gt;/&lt;/code&gt; збігається з дією аналогічних операторів в будь-якій іншій мові програмування (і в алгебрі). Їх можна застосовувати до даних будь-якого вбудованого числового типу.&lt;/p&gt;
&lt;p&gt;Перш за все хочу нагадати, що після застосування оператора ділення (&lt;code&gt;/&lt;/code&gt;) до цілого числа залишок буде відкинутий. Наприклад, результат цілочисельного ділення &lt;code&gt;10/3&lt;/code&gt; дорівнюватиме &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Залишок від ділення можна отримати за допомогою оператора ділення по модулю (%). Цей оператор працює практично так само, як в інших мовах програмування: повертає залишок від ділення без остачі. Наприклад, &lt;code&gt;10%3&lt;/code&gt; рівне &lt;code&gt;1&lt;/code&gt;. У С# оператор &lt;code&gt;%&lt;/code&gt; можна застосувати як до цілочисельних типів, так і типам з плаваючою крапкою. Наприклад, &lt;code&gt;10,0%3,0&lt;/code&gt; також рівне &lt;code&gt;1&lt;/code&gt;. (У мовах C/C++ операції ділення по модулю застосовні лише до цілочисельних типів.)&lt;/p&gt;
&lt;h3 id=&#34;chapter432&#34;&gt;4.3.2. Інкремент і декремент&lt;/h3&gt;
&lt;p&gt;Оператори інкремента (&lt;code&gt;++&lt;/code&gt;) і декремента (&lt;code&gt;--&lt;/code&gt;) збільшують і зменшують значення операнда на
одиницю, відповідно. Як буде показано нижче, ці оператори володіють спеціальними
властивостями, які роблять їх цікавими для розгляду. Отже, оператор інкремента виконує складання операнда з числом 1, а оператор декремента віднімає 1 зі свого операнда. Це означає, що інструкція&lt;/p&gt;
&lt;p&gt;&lt;code&gt;х = х + 1;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;аналогічна такій інструкції:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;х++&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Так само інструкція&lt;/p&gt;
&lt;p&gt;&lt;code&gt;х = х - 1;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;аналогічна такій інструкції:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;х--&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Оператори інкремента і декремента можуть стояти як перед своїм операндом, так і після нього.
Наприклад, інструкцію &lt;code&gt;х = х - 1;&lt;/code&gt; можна переписати у вигляді префіксної форми&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;++х; // Префіксна форма оператора інкремента
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;або у вигляді постфіксної форми:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;х++; // Постфіксна форма оператора інкремента
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У попередньому прикладі не мало значення, в якій формі був застосований оператор інкремента:
префіксній або постфіксній. Але якщо оператор інкремента або декремента використовується як
частина більшого виразу, то форма його використання має важливе значення.&lt;/p&gt;
&lt;p&gt;Якщо такий оператор застосований в префіксній формі, то С# спочатку виконає цю операцію, аби операнд набув нового значення, яке потім буде використано останньою частиною вираження. Якщо ж оператор застосований в постфіксній формі, то С# використовує у вираженні його старе значення, а потім виконає операцію, в результаті якої операнд знайде нове значення. Розглянемо наступний фрагмент коду:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;х = 10; 
int a = ++х;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Результат: a = 11;&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;х = 10; 
int a = х++;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Результат: a = 10;&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;chapter433&#34;&gt;4.3.3. Логічні оператори. Оператори відношення&lt;/h3&gt;
&lt;p&gt;Результат виконання операторів відношення і логічних операторів має тип &lt;code&gt;bool&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.4. Оператори відношення і логічні оператори&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Оператор&lt;/th&gt;
&lt;th&gt;Дія&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;==&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Рівно&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Не рівно&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Більше&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Менше&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Більше або рівно&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Менше або рівно&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;І&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;|&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Або&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;^&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Виключаюче або&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;||&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Скорочене або&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Скорочене і&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Не&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;У С# на рівність або нерівність можна порівнювати (відповідно, за допомогою операторів &lt;code&gt;==&lt;/code&gt; та &lt;code&gt;!=&lt;/code&gt;) всі об&amp;rsquo;єкти. Але такі оператори порівняння, як &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;=&lt;/code&gt; або &lt;code&gt;&amp;gt;=&lt;/code&gt;, можна застосовувати лише до типів, які підтримують відношення впорядкування. Це означає, що всі оператори відношення можна застосовувати до всіх числових типів. Проте значення типу &lt;code&gt;bool&lt;/code&gt; можна порівнювати лише на рівність або нерівність, оскільки значення &lt;code&gt;true&lt;/code&gt; і &lt;code&gt;false&lt;/code&gt; не упорядковуються. Наприклад, в С# порівняння &lt;code&gt;true &amp;gt; false&lt;/code&gt; не має сенсу.&lt;/p&gt;
&lt;p&gt;Що стосується логічних операторів, то їх операнди повинні мати тип &lt;code&gt;bool&lt;/code&gt;, і результат логічної операції завжди матиме тип &lt;code&gt;bool&lt;/code&gt;. Логічні оператори &lt;em&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code&gt;|&lt;/code&gt;&lt;/em&gt;, &lt;em&gt;&lt;code&gt;^&lt;/code&gt;&lt;/em&gt; і &lt;em&gt;&lt;code&gt;!&lt;/code&gt;&lt;/em&gt; виконують базові логічні операції &lt;code&gt;І&lt;/code&gt;, &lt;code&gt;АБО&lt;/code&gt;, &lt;code&gt;взаємовиключення&lt;/code&gt; і &lt;code&gt;НЕ&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.11. Оператори відношення та логічні оператори.&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;static void Main(string[] args)
{
    int a = 10, b = 11;
    bool abool = true, bbool = false;

    if(a &amp;gt; b) Console.WriteLine(&amp;quot;a &amp;gt; b&amp;quot;);                             //false
    if(a &amp;lt; b) Console.WriteLine(&amp;quot;a &amp;lt; b&amp;quot;);                             //true

    if(a == b) Console.WriteLine(&amp;quot;a == b&amp;quot;);                           //false
    if(a != b) Console.WriteLine(&amp;quot;a != b&amp;quot;);                           //true
    if (abool || bbool) Console.WriteLine(&amp;quot;abool || bbool - true&amp;quot;);   //true
    if (abool &amp;amp;&amp;amp; bbool) Console.WriteLine(&amp;quot;abool &amp;amp;&amp;amp; bbool - true&amp;quot;);   //false
    if (abool ^ bbool) Console.WriteLine(&amp;quot;abool ^ bbool - true&amp;quot;);     //true
    if (!abool) Console.WriteLine(&amp;quot;!abool - true&amp;quot;);                   //false
} 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;chapter434&#34;&gt;4.3.4. Інші оператори&lt;/h3&gt;
&lt;p&gt;Окрім базовового набору, у C# доступний набір і інших операторів, що використовуються під час написання програм. Опишемо їх коротко у вигляді таблиць з описами.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.5. Інші оператори&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Дія&lt;/th&gt;
&lt;th&gt;Оператор&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Доступ до членів&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Індексація&lt;/td&gt;
&lt;td&gt;&lt;code&gt;**[]**&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Приведення типів&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Тернарний оператор&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;?:&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Створення нового об’єкта&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;new()&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Інформація про тип даних&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;is&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Управління виключеннями переповнення&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;checked&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;unchecked&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Є також і інші оператори у C#. Ми розглянули лише основні, які будемо використовувати у нашому
курсі.&lt;/p&gt;
&lt;p&gt;При присворенні виразів аналогічно до алгебри враховується пріоритет операцій:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.6. Пріоритет операцій&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Пріор.&lt;/th&gt;
&lt;th&gt;Оператор&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;()&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;.&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;(постфікс)++&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;(постфікс)––&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;new&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;sizeof&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;typeof&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;unchecked&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;!&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;~&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;(ім’я типу)&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;+(унарний)&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;–(унарний)&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;++(префікс)&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;––(префікс)&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;*&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;/&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;%&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;+&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;–&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;lt;&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;gt;&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;=&amp;gt;&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;is&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;==&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;!=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;amp;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;^&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;|&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;12&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;||&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;13&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;?:&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;14&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;+=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;–=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;*=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;/=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;%=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;amp;=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;|=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;^=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;lt;&amp;lt;=&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;&amp;gt;&amp;gt;=&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Оператор присвоєння має додаткові можливості.&lt;/p&gt;
&lt;p&gt;Присвоєння можна проводити наступним чином:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int a, b, c; 
  int d = c = b = c = 3.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У результаті виконання коду усі змінні будуть ініціалізовані значенням &lt;code&gt;3&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;У &lt;code&gt;C#&lt;/code&gt;, так само як і у &lt;code&gt;С++&lt;/code&gt;, є складений оператор присвоєння. Для виразу &lt;code&gt;x = x + 10&lt;/code&gt; складений оператор матиме вигляд: &lt;code&gt;x += 10&lt;/code&gt;. Складений оператор означає додавання до поточного значення певного числа. Аналогічні операції можна застосовувати і до
інших операторів: &lt;strong&gt;&lt;code&gt;-=&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;*=&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;/=&lt;/code&gt;&lt;/strong&gt;, &lt;strong&gt;&lt;code&gt;%=&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;h2 id=&#34;chapter44&#34;&gt;4.4. Літерали&lt;/h2&gt;
&lt;p&gt;У програмах на мовах високого рівня (у тому числі C#) &lt;strong&gt;літералами&lt;/strong&gt; називають послідовність
символів, що входять у алфавіт мови програмування, які забезпечують явне представлення значень, які використовуються для позначення початкових значень в оголошенні членів класів, змінних і
констант в методах класу. Розрізняються літерали &lt;code&gt;арифметичні&lt;/code&gt; (різних типів), &lt;code&gt;логічні&lt;/code&gt;, &lt;code&gt;символьні&lt;/code&gt;
(включаючи Escape-послідовності), &lt;code&gt;рядкові&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;chapter441&#34;&gt;4.4.1. Арифметичні літерали&lt;/h3&gt;
&lt;p&gt;Арифметичні літерали кодують значення різних (арифметичних) типів. Тип арифметичного
літерала визначається наступними інтуїтивно зрозумілими зовнішніми ознаками:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;стандартним зовнішнім виглядом&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Значення цілочисельного типу зазвичай кодується інтуїтивно
зрозумілою послідовністю символів $1, 2, 3, &amp;hellip; N$.&lt;/p&gt;
&lt;p&gt;Значення чисел з дробовою частиною також передбачає
стандартний вигляд (крапка-роздільник між цілою і дробовою частиною, або наукова або
експоненціальна нотація - $1.2500E+052$).&lt;/p&gt;
&lt;p&gt;Шістнадцяткове представлення цілочисельного значення кодується шістнадцятковим літералом, що складається з символів $0, &amp;hellip;, 9$, а також $&amp;lsquo;a&amp;rsquo; &amp;hellip;, &amp;lsquo;f&amp;rsquo;$, або $&amp;lsquo;A&amp;rsquo; &amp;hellip;,
&amp;lsquo;F&amp;rsquo;$ з префіксом &lt;code&gt;&#39;0x&#39;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;власне значенням&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Так, накприклад, 32768 ніяк не може бути значенням типу &lt;code&gt;short&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;strong&gt;додатковим суфіксом&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Суфікси &lt;code&gt;l&lt;/code&gt;, &lt;code&gt;L&lt;/code&gt; відповідають типові &lt;code&gt;long&lt;/code&gt;; &lt;code&gt;ul&lt;/code&gt;, &lt;code&gt;UL&lt;/code&gt; - &lt;code&gt;unsigned long&lt;/code&gt;; &lt;code&gt;f&lt;/code&gt;, &lt;code&gt;F&lt;/code&gt; - &lt;code&gt;float&lt;/code&gt;; &lt;code&gt;d&lt;/code&gt;, &lt;code&gt;D&lt;/code&gt; -
&lt;code&gt;double&lt;/code&gt;, &lt;code&gt;M&lt;/code&gt;, &lt;code&gt;m&lt;/code&gt; - &lt;code&gt;decimal&lt;/code&gt;. Значення типу &lt;code&gt;double&lt;/code&gt; кодуються також без префікса з вказанням розділювача дробової частини, наприклад, $25.0$.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;chapter442&#34;&gt;4.4.2. Логічні літерали&lt;/h3&gt;
&lt;p&gt;До логічних літералів відносяться наступні послідовності символів: &lt;code&gt;true&lt;/code&gt; і &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;chapter443&#34;&gt;4.4.3. Символьні літерали&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Символьні літерали&lt;/strong&gt; - це взяті в одинарні лапки символи, що вводяться з клавіатури, наприклад, &lt;code&gt;&#39;X&#39;&lt;/code&gt;, &lt;code&gt;&#39;p&#39;&lt;/code&gt;, &lt;code&gt;&#39;Q&#39;&lt;/code&gt;, &lt;code&gt;&#39;7&#39;&lt;/code&gt;, а також цілочисельні значення в діапазоні від $0$ до $65535$, перед якими розташовується конструкція вигляду &lt;code&gt;(char)&lt;/code&gt; - операція явного приведення до типу &lt;code&gt;char&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Наступні взяті в одинарні лапки послідовності символів є &lt;code&gt;Escape&lt;/code&gt;-послідовностями. Ця категорія
літералів використовується для створення додаткових ефектів (дзвінок), простого форматування
інформації, що виводиться, і кодування символів при виводі і порівнянні (у виразах порівняння).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.7.Символьні Escape-послідовності&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Команда&lt;/th&gt;
&lt;th&gt;Пояснення&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\a&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Звуковий сигнал&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\b&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Повернення на одну позицію назад&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\f&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Перехід на нову сторінку&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\n&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Перехід на новий рядок&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\r&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Повернення каретки&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\t&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Горизонтальна табуляція&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\v&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Вертикальна табуляція&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\0&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Нуль&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\&#39;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Одинарна лапка&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\&amp;quot;&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Подвійна лапка&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;&lt;code&gt;\\&lt;/code&gt;&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;Зворотна коса лінія&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Рядкові літерали&lt;/strong&gt; - це послідовність символів і символьних &lt;code&gt;Escape&lt;/code&gt;-послідовностей, взятих у подвійні
лапки.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;Verbatim string&lt;/code&gt;&lt;/strong&gt; - рядковий літерал, що інтерпретується компілятором так, як він записаний. &lt;code&gt;Escape&lt;/code&gt;-послідовності сприймаються строго як послідовності символів.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Verbatim string&lt;/code&gt; представляється за допомогою символу &lt;strong&gt;&lt;code&gt;@&lt;/code&gt;&lt;/strong&gt;, який розташовується безпосередньо
перед текстом, взятим в парні подвійні лапки. Представлення подвійних лапок в
&lt;code&gt;Verbatim string&lt;/code&gt; забезпечується їх дублюванням.&lt;/p&gt;
&lt;p&gt;Пара літералів (другий - Verbatim string)&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  ...&amp;quot;c:\\My Documents\\sample.txt&amp;quot;...
  ...@&amp;quot;c:\My Documents\sample.txt&amp;quot;...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;мають одне і те ж значення: &lt;code&gt;c:\My Documents\sample.txt&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Рядкові літерали є об&amp;rsquo;єктами типу &lt;code&gt;string&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&#34;chapter45&#34;&gt;4.5. Приведення типів даних&lt;/h2&gt;
&lt;p&gt;Приведення типів - один з аспектів безпеки будь-якої мови програмування.&lt;/p&gt;
&lt;p&gt;Використовувані в програмі типи характеризуються власними діапазонами значень, які
визначаються властивостями типів, у тому числі і розміром області пам&amp;rsquo;яті, призначеної для
кодування значень відповідного типу. При цьому області значень різних типів перетинаються.&lt;/p&gt;
&lt;p&gt;Багато значень можна виразити більш ніж одним типом. Наприклад, значення 4 можна
представити як значення типу &lt;code&gt;sbyte&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;short&lt;/code&gt;, &lt;code&gt;ushort&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;, &lt;code&gt;ulong&lt;/code&gt;. При цьому в програмі все повинно бути влаштовано так, щоб логіка перетворення значень одного типу до іншого 
була зрозумілою, а результати цих перетворень - передбачувані.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Інколи приведення значення до іншого типу відбувається автоматично.&lt;/em&gt; Такі перетворення
називаються &lt;strong&gt;неявними&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Але у ряді випадків перетворення вимагає додаткової уваги з боку програміста, який повинен &lt;strong&gt;явним&lt;/strong&gt;
чином вказувати необхідність перетворення, використовуючи вирази приведення типу або звертаючись до спеціальних методів перетворення, визначеним в класі &lt;code&gt;System.Convert&lt;/code&gt;, які забезпечують перетворення значення одного типу до значення іншого.&lt;/p&gt;
&lt;p&gt;Перетворення типу створює значення нового типу, еквівалентне значенню старого типу, проте при
цьому не обов&amp;rsquo;язково зберігається ідентичність (або точні значення) двох об&amp;rsquo;єктів.&lt;/p&gt;
&lt;p&gt;Розрізняють &lt;strong&gt;розширююче&lt;/strong&gt; та &lt;strong&gt;звужуюче&lt;/strong&gt; перетворення.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Розширююче перетворення&lt;/strong&gt; - значення одного типу перетвориться до значення іншого типу, яке має
такий же або більший розмір. Наприклад, значення, представлене у вигляді 32-розрядного цілого
числа із знаком, може бути перетворене в 64-розрядне ціле число із знаком. Розширене
перетворення вважається безпечним, оскільки вихідна інформація при такому перетворенні не
спотворюється.&lt;/p&gt;
&lt;p&gt;Можливість розширеного перетворення представлено у таблиці нижче.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.8. Можливість розширеного перетворення типів даних&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Тип, що перетворюється&lt;/th&gt;
&lt;th&gt;У який тип перетворюється&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SByte&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Char&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Single&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;Double&lt;/code&gt;, &lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Single&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;Звужуюче перетворення&lt;/strong&gt; - значення одного типу перетвориться до значення іншого типу, яке має
менший розмір (з 64-розрядного в 32-розрядне). Таке перетворення потенційне небезпечне втратою
значення. Звужуючі перетворення можуть призводити до втрати інформації.&lt;/p&gt;
&lt;p&gt;Якщо тип, до якого здійснюється перетворення, не може правильно передати значення джерела, то результат
перетворення виявляється дорівнює константі &lt;code&gt;PositiveInfinity&lt;/code&gt; або &lt;code&gt;NegativeInfinity&lt;/code&gt;. &lt;em&gt;Примітка. Перевірити інформацію!&lt;/em&gt; При цьому значення &lt;code&gt;PositiveInfinity&lt;/code&gt; інтерпретується як результат ділення додатнього числа на нуль, а значення &lt;code&gt;NegativeInfinity&lt;/code&gt; - як результат ділення відємного числа на нуль. Якщо звужуюче перетворення
забезпечується методами класу &lt;code&gt;System.Convert&lt;/code&gt;, то втрата інформації супроводиться генерацією
виключення (про виключення пізніше).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.9. Можливість звужуючого перетворення типів даних&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Тип, що перетворюється&lt;/th&gt;
&lt;th&gt;У який тип перетворюється&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Sbyte&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;SByte&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Int16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UInt16&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Int32&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UInt32&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Int64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;UInt64&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Decimal&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Single&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;UInt64&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;Double&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;Byte&lt;/code&gt;, &lt;code&gt;SByte&lt;/code&gt;, &lt;code&gt;Int16&lt;/code&gt;, &lt;code&gt;UInt16&lt;/code&gt;, &lt;code&gt;Int32&lt;/code&gt;, &lt;code&gt;UInt32&lt;/code&gt;, &lt;code&gt;Int64&lt;/code&gt;, &lt;code&gt;UInt6&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.12. Звужуюче перетворення&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;public static void Main()
{
    int i = 1234567;
    short s = (short)i;
    Console.WriteLine(&amp;quot;int - {0}\n short - {1}&amp;quot;, i,s);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  int - 1234567
  short - -10617
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;chapter46&#34;&gt;4.6. Робота з памяттю у С#&lt;/h2&gt;
&lt;h3 id=&#34;chapter461&#34;&gt;4.6.1. &amp;ldquo;Стек&amp;rdquo; і &amp;ldquo;купа&amp;rdquo;&lt;/h3&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Звершити розділ
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;Стек&lt;/strong&gt; (&lt;code&gt;Stack&lt;/code&gt;) відноситься до області пам&amp;rsquo;яті, підтримуваної процесором, в якій зберігаються локальні змінні.
Доступ до стека у багато разів швидший, ніж до загальної області пам&amp;rsquo;яті, тому використання стека
для зберігання даних прискорює роботу вашої програми. У С# розмірні типи (наприклад, цілі
числа) розташовуються в стеку: для їх значень зарезервована область в стеку, і доступ до неї
здійснюється по назві змінної.&lt;/p&gt;
&lt;p&gt;Посилальні типи (наприклад, об&amp;rsquo;єкти) розташовуються в &lt;strong&gt;купі&lt;/strong&gt; (&lt;code&gt;Heap&lt;/code&gt;). &lt;strong&gt;Купа&lt;/strong&gt; — це оперативна пам&amp;rsquo;ять
вашого комп&amp;rsquo;ютера. Доступ до неї здійснюється повільніше, ніж до стека. Коли об&amp;rsquo;єкт
розташовується в купі, то змінна зберігає лише адресу об&amp;rsquo;єкта. Ця адреса зберігається в стеку. За адресою програма має доступ до самого об&amp;rsquo;єкту, всі дані якого зберігаються в загальній пам&amp;rsquo;яті (купі).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;«Збиральник сміття»&lt;/strong&gt; (&lt;code&gt;Garbage Collector&lt;/code&gt;) знищує об&amp;rsquo;єкти, розташовані в стеку, кожен раз, коли
відповідна змінна виходить за область видимості. Таким чином, якщо ви оголошуєте локальну
змінну в межах функції, то об&amp;rsquo;єкт буде помічений як об&amp;rsquo;єкт для «збирання сміття». І він буде
видалений з пам&amp;rsquo;яті після завершення роботи функції. Об&amp;rsquo;єкти у купі теж очищаються
збиральником сміття, після того, як кінцеве посилання на них буде знищено.&lt;/p&gt;
&lt;h3 id=&#34;chapter462&#34;&gt;4.6.2. Типи-посилання та типи-значення&lt;/h3&gt;
&lt;p&gt;Усі типи даних у C# поділяються на &lt;strong&gt;значимі&lt;/strong&gt; (&lt;code&gt;ValueType&lt;/code&gt;) та &lt;strong&gt;типи-посилання&lt;/strong&gt; (&lt;code&gt;ReferenceType&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Значимі типи:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;містять у собі об’єкти даних;&lt;/li&gt;
&lt;li&gt;не можуть бути пустими.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Типи-посилання:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;містять у собі посилання на об’єкт даних;&lt;/li&gt;
&lt;li&gt;можуть бути пустими (null).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Які типи даних відносяться до значимих, а які до типів-посилань було розглянуто у &lt;a href=&#34;#chapter41&#34;&gt;питанні 4.1&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Запишемо простий приклад:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;int a = 1000;
int b = a;
b = 2000;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Логічно, що після виконання цього коду &lt;code&gt;a = 1000&lt;/code&gt;, &lt;code&gt;b = 2000&lt;/code&gt; - це принцип роботи значимих типів - у
змінну копіюється значення і не привязується до змінної з якої воно було взяте.&lt;/p&gt;
&lt;p&gt;Тепер давайте створимо просту структуру &lt;code&gt;Point&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.13. Використання структури (значимий тип).&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;struct Point
{
    public int x;
    public int y;
} 

static void Main(string[] args)
{
    Point point1 = new Point();
    point1.x = 111;
    point1.y = 111;

    //Виведемо на екран змінну point1
    Console.WriteLine(&amp;quot;point1.x = {0}; point1.y = {1}&amp;quot;, point1.x, point1.y);

    // Створимо змінну point2
    Point point2 = point1;

    //Виведемо на екран змінну point2
    Console.WriteLine(&amp;quot;point2.x = {0}; point2.y = {1}&amp;quot;, point2.x, point2.y);

    Console.WriteLine(&amp;quot;\t---- Change point 2-----&amp;quot;);
    //Змінимо значення параметрів у point2
    point2.x = 777;
    point2.y = 777;
    //Виведемо point1 та point2
    Console.WriteLine(&amp;quot;point1.x = {0}; point1.y = {1}&amp;quot;, point1.x, point1.y);
    Console.WriteLine(&amp;quot;point2.x = {0}; point2.y = {1}&amp;quot;, point2.x, point2.y);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання коду:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;point1.x = 111; point1.y = 111
point2.x = 111; point2.y = 111
        ---- Change point 2-----
point1.x = 111; point1.y = 111
point2.x = 777; point2.y = 777
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Як бачимо після зміни значень х та у для змінної &lt;code&gt;point2&lt;/code&gt; значення змінної &lt;code&gt;рoint1&lt;/code&gt; не змінилося! Все
правильно, адже структура є значимим типом і тому відбувається копіювання значень при
присвоєнні.&lt;/p&gt;
&lt;p&gt;Тепер давайте замінимо структуру &lt;code&gt;Point&lt;/code&gt; на клас.&lt;/p&gt;
&lt;p&gt;Приклад 12. Використання класу (посилальний тип).

  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 4.14. Використання класу (посилальний тип)&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;class Point
{
  public int x;
  public int y;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання коду:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;point1.x = 111; point1.y = 111
point2.x = 111; point2.y = 111
        ---- Change point 2-----
point1.x = 777; point1.y = 777
point2.x = 777; point2.y = 777
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Як бачимо значення &lt;code&gt;point1&lt;/code&gt; змінилося. Посилальні типи даних вказують лише на ділянку пам&amp;rsquo;яті, у
якій знаходиться значення, а не на саме значення. При присвоєнні не відбувається копіювання
значень, а копіювання посилання.&lt;/p&gt;
&lt;p&gt;Для узагальнення опишемо все це у таблиці:&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Таблиця 4.10. Можливість звужуючого перетворення типів даних&lt;/em&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Характеристика&lt;/th&gt;
&lt;th&gt;Значимий тип&lt;/th&gt;
&lt;th&gt;Тип-посилання&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Змінна містить&lt;/td&gt;
&lt;td&gt;Значення&lt;/td&gt;
&lt;td&gt;Посилання на значення&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Змінна зберігається&lt;/td&gt;
&lt;td&gt;У стеку&lt;/td&gt;
&lt;td&gt;У кучі&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Значення по замовчуванню&lt;/td&gt;
&lt;td&gt;&lt;code&gt;0&lt;/code&gt;, &lt;code&gt;false&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&#39;\0&#39;&lt;/code&gt;, &lt;code&gt;null&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Оператор присвоєння&lt;/td&gt;
&lt;td&gt;Копіює значення&lt;/td&gt;
&lt;td&gt;Копіює посилання&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;Коментар до таблиці:&lt;/p&gt;
&lt;p&gt;Змінна в разі використання типів-значень містить власне значення, а при
використанні типів-посилань – не саме значення, а лише посилання на нього. Місцем зберігання
змінної, визначеної як тип-значення, є стек, а визначеною як посилальний тип – «купа» (останнє
необхідне для динамічного виділення і звільнення пам&amp;rsquo;яті для зберігання змінної довільним чином).&lt;/p&gt;
&lt;p&gt;Значенням, яким змінна ініціалізувалася за умовчанням (необхідність виконання цієї вимоги
диктується ідеологією безпеки Microsoft .NET) в разі визначення за допомогою типу-значення є &lt;code&gt;0&lt;/code&gt;
(для чисельного типу даних), &lt;code&gt;false&lt;/code&gt; (для логічного типу даних), &lt;code&gt;&#39;\0&#39;&lt;/code&gt; (для символьного типу даних), а в
разі визначення за допомогою типу-посилання – значення порожнього посилання &lt;code&gt;null&lt;/code&gt;.&lt;/p&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4t&#34;&gt;Задачі&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Задача 1.&lt;/strong&gt; Виведіть на екран наступний текст:&lt;/p&gt;
&lt;pre&gt;&#34;Саме знання нікому їсти не дасть.&#34;
                      \І. Я. Франко\&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Задача 2.&lt;/strong&gt; Напишіть програму, яка обчислює суму, добуток, різницю, частку та остачу від ділення двох заданих чисел.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 3.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Напишіть програму, яка конвертує суму грн. у євро.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 4.&lt;/strong&gt; Напишіть попередню програму з умовою, що суму у грн. та курс валюти задає користувач.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Написати програму, яка обчислює квадрат введеного числа.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 6&lt;code&gt;*&lt;/code&gt;.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Написати програму, яка замінює місцями значення двох
числових змінних без створення третьої змінної.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 7.&lt;/strong&gt; Обрахувати ціну покупки, якщо відомо:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ціну за одиницю товару;&lt;/li&gt;
&lt;li&gt;кількість товару;&lt;/li&gt;
&lt;li&gt;знижка (у % від загальної суми).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Задача 8.&lt;/strong&gt; Дано катети прямокутного трикутника (вводяться з клавіатури користувачем). Визначити довжину гіпотенузи.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 9.&lt;/strong&gt; У C# немає функції, яка обчислює квадрат числа. Написати програму, яка обчислює квадрат введеного числа.&lt;/p&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-question-circle fa-2x text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4c&#34;&gt;Контрольні запитання&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Що таке тип даних?&lt;/li&gt;
&lt;li&gt;Дайте класифікацію типів даних .NET.&lt;/li&gt;
&lt;li&gt;Що таке змінна? Який синтаксис оголошення змінної.&lt;/li&gt;
&lt;li&gt;Що таке констаната? Який синтаксис оголошення констант?&lt;/li&gt;
&lt;li&gt;Що таке область видимості змінної?&lt;/li&gt;
&lt;li&gt;Які види операторів існують у C#?&lt;/li&gt;
&lt;li&gt;Що таке інкремент та декремент? Яка різниця між постфіксним та
прфіксним записом цих операторів?&lt;/li&gt;
&lt;li&gt;Що таке літерал? Який синтаксис запису літералів для різних типів
даних.&lt;/li&gt;
&lt;li&gt;Що таке привдення типів даних?
10.Яка різниця та синтаксис явного та неявного привдення типів даних?
11.Опишіть основні характеристики значимих типів даних.
12.Опишіть основні характеристики посилальних типів даних.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-book fa-2x text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4s&#34;&gt;Список використаних джерел&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Albahari, J., &amp;amp; Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.&lt;/li&gt;
&lt;li&gt;Cardelli, L., &amp;amp; Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з &lt;a href=&#34;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&#34;&gt;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.&lt;/li&gt;
&lt;li&gt;MSDN. (без дати). Отримано з Microsoft Developer Network: &lt;a href=&#34;http://msdn.microsoft.com/&#34;&gt;http://msdn.microsoft.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Биллиг, А. (2005). Основы программирования на C#. Москва, Россия: НОУ ИНТУИТ.&lt;/li&gt;
&lt;li&gt;Нейгел, К. И. (2011). С# 4.0 и платформа .NET 4 для профессионалов. Москва, Россия: ООО &amp;ldquo;И.Д. Вильямс&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Павловская, Т. (2009). С#. Программирование на языке высокого уровня. Учебник для вузов. СПб, Россия: Питер.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-download fa-2x  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4a&#34;&gt;Додаткові матеріали для завантаження&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі DOCX &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-word  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі PDF &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-pdf  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;Діаграми до лекції у форматі &lt;code&gt;
  &lt;i class=&#34;fas fa-project-diagram  pr-1 fa-fw&#34;&gt;&lt;/i&gt;draw.io&lt;/code&gt; на &lt;code&gt;
  &lt;i class=&#34;fab fa-github  pr-1 fa-fw&#34;&gt;&lt;/i&gt;github&lt;/code&gt; &lt;a href=&#34;https://github.com/kleban/csharp-basics-public/tree/master/diagrams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Перейти&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Лекція 5. Оператори розгалуження та цикли</title>
      <link>/courses/csharp-basics/lecture5/</link>
      <pubDate>Tue, 06 Apr 2021 00:00:00 +0100</pubDate>
      <guid>/courses/csharp-basics/lecture5/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter51&#34;&gt;5.1. Оператори розгалуження&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter511&#34;&gt;5.1.1. Оператор &lt;code&gt;if-else&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter512&#34;&gt;5.1.2. Оператор &lt;code&gt;switch&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter513&#34;&gt;5.1.3. Тернарний оператор&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter52&#34;&gt;5.2. Використання циклів під час написання програм&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter521&#34;&gt;5.2.1. Цикл &lt;code&gt;for&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter522&#34;&gt;5.2.2.Цикли &lt;code&gt;while&lt;/code&gt; та &lt;code&gt;do-while&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter5samples&#34;&gt;Приклади розв&amp;rsquo;язання задач&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter5tasks&#34;&gt;Задачі&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter5solutions&#34;&gt;Рішення до задач&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4qustions&#34;&gt;Контрольні запитання&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4sourses&#34;&gt;Список використаних джерел&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter4a&#34;&gt;Додаткові матеріали для завантаження&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter51&#34;&gt;5.1. Оператори розгалуження&lt;/h2&gt;
&lt;p&gt;У C# для реалізації розгалужень коду використовуються
спеціальні оператори: &lt;code&gt;if-else&lt;/code&gt;, &lt;code&gt;switch&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;chapter511&#34;&gt;5.1.1. Оператор &lt;code&gt;if-else&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Якщо є потреба перевірити у коді програми виконання якоїсь
умови та за її результатами перейти до одного із блоків програми
зазвичай використовують оператор &lt;code&gt;if-else&lt;/code&gt;. Загальний вигляд формату
використання оператора &lt;code&gt;if-else&lt;/code&gt; зображений у лістингу 5.1.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.1. Формат використання оператора &lt;code&gt;if-else&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  if (умова)
  {
    //інструкція
  }
  else
  {
    //інструкція
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вираз «умова» завжди повинен повертати результат у вигляді елемента логічного типу. Тобто, «умова» може бути або &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;, або &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Якщо «умова» рівна &lt;strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;/strong&gt;, то виконається інструкція (або код) записана у дужках після &lt;strong&gt;&lt;code&gt;if&lt;/code&gt;&lt;/strong&gt;. Якщо ж «умова» рівна &lt;strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;/strong&gt;, то виконається інструкція записана у дужках після &lt;strong&gt;&lt;code&gt;else&lt;/code&gt;&lt;/strong&gt;.&lt;/p&gt;
&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;div&gt;
    Якщо після &lt;code&gt;if&lt;/code&gt; або &lt;code&gt;else&lt;/code&gt; тільки одна інструкція (можна ототожнити з один рядком коду), то «фігурні» дужки &lt;code&gt;{}&lt;/code&gt; не є обов’язковими.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Розглянемо приклад: написати програму, що визначає парність/непарність числа. Тобто, користувач вводить число, а програма показує на консоль у текстовому вигляді: &lt;code&gt;«парне»&lt;/code&gt; або &lt;code&gt;«непарне»&lt;/code&gt; (лістинг 5.2).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.2. Перевірка числа на парність&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int a = int.Parse(Console.ReadLine());
  if(a % 2 == 0)
    Console.WriteLine(&amp;quot;парне&amp;quot;);
  else
    Console.WriteLine(&amp;quot;непарне&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Конструкції &lt;code&gt;if-else&lt;/code&gt; можуть вкладеними одна в одну без обмежень
по глибині (лістинг 5.3). Проте дуже глибокої вкладеності варто уникати,
адже це ускладнює читання та розуміння коду програми.&lt;/p&gt;
&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;div&gt;
    &lt;code&gt;if&lt;/code&gt; є обов’язковим і повинно існувати у всіх подібних
конструкціях, у той же час &lt;code&gt;else&lt;/code&gt; – необов’язковий.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.3. Приклад використання вкладених операторів if-else&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  if (умова1)
  {
    if (умова2)
    {
      //інструкція
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Також конструкція &lt;code&gt;if-else&lt;/code&gt; може мати структуру дерева із багатьма
розгалуженнями. Така структура зазвичай записується як&lt;code&gt; if-else-if&lt;/code&gt;
(лістинг 5.4).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.4. Формат запису &lt;code&gt;if-else-if&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  if (умова)
  {/*код*/}
  else if (умова)
      {/*код*/}
      else if (умова)
          {/*код*/}
          else {/*код*/}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Вирази обчислюються зверху-вниз. Якщо один із виразів (&lt;code&gt;«умова»&lt;/code&gt;) отримає істинний результат, то програмний код, пов&amp;rsquo;язаний із цією гілкою розгалуження виконається, а всі інші гілки будуть 
пропущені. Якщо ж не виконається жодна з умов, то буде запущено код
всередині останньої інструкції &lt;code&gt;else&lt;/code&gt; (у цьому випадку &lt;code&gt;else&lt;/code&gt; теж не
обов’язковий).&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;chapter512&#34;&gt;5.1.2. Оператор &lt;code&gt;switch&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Наступною інструкцією для реалізації розгалуження, або
точніше вибору значення є &lt;code&gt;switch&lt;/code&gt;. &lt;code&gt;Switch&lt;/code&gt; забезпечує багатонаправлене
розгалуження і дозволяє вибрати один із варіантів із даної множини
альтернатив. Ця конструкція працює наступним чином:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Значення виразу послідовно порівнюється з константами із заданого списку.&lt;/li&gt;
&lt;li&gt;При виявленні збігу для однієї з умов порівняння виконується послідовність інструкцій, пов&amp;rsquo;язана з цією умовою.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Оператор &lt;code&gt;switch&lt;/code&gt; приймає значення цілочисельного типу (наприклад, &lt;code&gt;char&lt;/code&gt;, &lt;code&gt;byte&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt; тощо) або тип &lt;code&gt;string&lt;/code&gt;. Типи даних, що представляють числа з дробовою частиною не можуть бути використані даному випадку.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Switch&lt;/code&gt; складається з набору &lt;code&gt;case&lt;/code&gt; конструкцій. Кожна конструкція &lt;code&gt;case&lt;/code&gt; представлена у вигляді літерала такого ж типу даних як і значення, що приймає &lt;code&gt;switch&lt;/code&gt;. Усі &lt;code&gt;case&lt;/code&gt; конструкції у межах одного &lt;code&gt;switch&lt;/code&gt; можуть мати тільки унікальні константи. Формат оголошення продемонстровано у лістингу 5.5.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.5. Формат оголошення &lt;code&gt;switch&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  switch (значення)
  {
    case костанта1:
      //інструкція
      break;
    case костанта2:
      //інструкція;
      break;
    ...
    default:
      //інструкція
      break;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;Case&lt;/code&gt;-конструкції перевіряються у порядку розміщення. Вкінці
кожного &lt;code&gt;case&lt;/code&gt; повинно бути ключове слово &lt;code&gt;break&lt;/code&gt;, що означає вихід із
&lt;code&gt;switch&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Також у &lt;code&gt;switch&lt;/code&gt; використовують конструкцію &lt;code&gt;default&lt;/code&gt;, яка не є
обов’язковою і виконується лише у випадку, якщо жодна із &lt;code&gt;case&lt;/code&gt;-конструкцій так і не відпрацювала.&lt;/p&gt;
&lt;p&gt;Для розуміння принципів роботи &lt;code&gt;switch&lt;/code&gt; розглянемо приклад. Написати програму, яка у залежності від введеної цифри виводить на
консоль пору року: 1 — «Зима», 2 — «Весна», 3 — «Літо», 4 — «Осінь»,
інше число — «Введіть число із діапазону [1;4]» (лістинг 5.6).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.6. Розв’язання задачі «Пори року» з використанням &lt;code&gt;switch&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  Console.Write(&amp;quot;Введіть номер пори року [1;4]:\t&amp;quot;);
  int res = int.Parse(Console.ReadLine());
  
  switch (res)
  {
    case 1:
      Console.WriteLine(&amp;quot;Зима&amp;quot;);
      break;
    case 2:
      Console.WriteLine(&amp;quot;Весна&amp;quot;);
      break;
   case 3:
     Console.WriteLine(&amp;quot;Літо&amp;quot;);
     break;
   case 4:
     Console.WriteLine(&amp;quot;Зима&amp;quot;);
     break;
   default:
     Console.WriteLine(&amp;quot;Введіть число від 1 до 4&amp;quot;);
     break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Введіть номер пори року [1;4]: 2
  Весна
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У випадку, якщо потрібно, щоб одна і та ж інструкція виконувалася для кількох різних значень констант код &lt;code&gt;switch&lt;/code&gt; може мати
вигляд як на лістингу 5.7.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.7. Приклад використання &lt;code&gt;switch&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  Console.Write(&amp;quot;Введіть оцінку [1-12]:\t&amp;quot;);
  int res = int.Parse(Console.ReadLine());
  
  switch (res)
  {
     case 1:
     case 2:
     case 3:
       Console.WriteLine(&amp;quot;Низький рівень&amp;quot;);
       break;
     ...
     case 10:
     case 11:
     case 12:
       Console.WriteLine(&amp;quot;Високий рівень&amp;quot;);
       break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;У прикладі показано виведення шкільких оцінок відповідно до 12-ти бальної системи по рівнях.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;chapter513&#34;&gt;5.1.3. Тернарний оператор&lt;/h3&gt;
&lt;p&gt;Інколи для простої заміни оператора &lt;code&gt;if-else&lt;/code&gt; використовують тернарний оператор. Тернарний оператор отримав свою назву від
кількості задіяних виразів (3) і позначається символами &lt;code&gt;?:&lt;/code&gt;. Загальний
формат запису тернарного оператора має вигляд:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Вираз_1 ? Вираз_2 : Вираз_3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;де &lt;code&gt;Вираз_1&lt;/code&gt; — логічний вираз, за рузультатом обчислення якого визначається наступна дія, &lt;code&gt;Вираз_2&lt;/code&gt; — значення, що повертається, якщо результатом &lt;code&gt;Виразу_1&lt;/code&gt; є &lt;code&gt;true&lt;/code&gt;, &lt;code&gt;Вираз_3&lt;/code&gt; — значення, що повертається, якщо результатом &lt;code&gt;Виразу_1&lt;/code&gt; є &lt;code&gt;false&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Для демонстрації роботи тернарного оператора спробуємо розвязати задачу визначення модуля цілого числа. Можна було б для також задачі скористатися оператором &lt;code&gt;if-else&lt;/code&gt;, проте тернарний оператор
спрощує синтаксис запису такого коду (лістинг 5.8).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.8. Приклад використання тернарного оператора: визначення модуля числа&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  Console.Write(&amp;quot;Введіть ціле число:\t&amp;quot;);
  int a = Convert.ToInt32(Console.ReadLine());
  int absval = (a &amp;gt; 0) ? a : -a;
  Console.WriteLine(&amp;quot;ABS: {0}&amp;quot;, absval);
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;div&gt;
    Увага! Для знаходження модуля числа у C# існує спеціальний
метод &lt;code&gt;Math.Abs(значення)&lt;/code&gt;.
  &lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter52&#34;&gt;5.2. Використання циклів під час написання програм&lt;/h2&gt;
&lt;p&gt;Для виконання повторюваних операцій у програмуванні
використовуються цикли. Цикл – це спеціальна конструкція мови
програмування для багаторазового виконання набору інструкцій.
У C# існують 4 типи циклів: &lt;code&gt;for&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt;, &lt;code&gt;do-while&lt;/code&gt;, &lt;code&gt;foreach&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id=&#34;chapter521&#34;&gt;5.2.1. Цикл &lt;code&gt;for&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Загальний синтаксис оголошення циклу &lt;code&gt;for&lt;/code&gt; має вигляд як на
лістингу 5.9. Блок «ініціалізація» використовується для оголошення
керуючих змінних циклу. У другому блоці оголошення циклу
перевіряється умова можливості продовження виконання циклу. Якщо
«умова» повератає &lt;code&gt;false&lt;/code&gt;, то виконання циклу завершується. Блок
«інструкції» довляє виконувати дії над змінними програми. Найчастіше
у цьому блоці відбуваються дії над керуючими змінними.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.9. Синтаксис оголошення циклу &lt;code&gt;for&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  for(ініціалізація; умова; інструкції)
  {
    //код;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Усі три блоки «ініціалізація», «умова» та «інструкції» не є
обов’язковим у оголошенні циклу &lt;code&gt;for&lt;/code&gt;, проте розділювачі потрібно
записати обов’язково (лістинг 5.10).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.10. Вічний цикл &lt;code&gt;for&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  for(;;)
  {
    //код;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Розглянемо приклад задачі: знайти суму усіх чисел від 1 до 10-ти
включно (лістинг 5.11).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.11. Приклад використання циклу &lt;code&gt;for&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int sum = 0;
  for (int i = 1; i &amp;lt;= 10; ++i)
    sum += i;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&#34;alert alert-info&#34;&gt;
  &lt;div&gt;
    Якщо після &lt;code&gt;for&lt;/code&gt; тільки одна інструкція, то «фігурні» дужки &lt;code&gt;{}&lt;/code&gt; не є обов’язковими.
  &lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Для деталізації розглянемо ще один приклад програми і
розберемо його (лістинг 5.12).&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.12. Приклад використання циклу &lt;code&gt;for&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int sum = 0;
  for (int i = 0, j = 1; sum &amp;lt; 20; i++, j += 2)
  {
      sum += i + j;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Проаналізуємо, як повинна відпрацювати дана програма та які
значення будуть мати змінні на кожній ітерації циклу.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;Початок: i = 0; j = 1; sum = 0.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;1-ша ітерація: i = 1; j = 3; sum = 5.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;2-га ітерація: i = 2; j = 5; sum = 12.&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;3-тя ітерація: i = 3; j = 7; sum = 22&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Також у циклах можуть використовуватися ключові слова &lt;code&gt;break&lt;/code&gt;
та &lt;code&gt;continue&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ключове слово &lt;code&gt;break&lt;/code&gt; зупиняє виконання циклу і переходить до
виконання наступного після циклу коду. Ключове слово &lt;code&gt;continue&lt;/code&gt;
переводить цикл на нову ітерацію.&lt;/p&gt;
&lt;p&gt;На прикладі лістингу 5.13. розглянемо використання цих
операторів. Програма працює наступним чином: цикл послідовно
проходить по усіх числах та виводить їх на екран; якщо число кратне 3-м, то цикл переходить на нову ітерацію; якщо число кратне 7-ми, то цикл закінчується.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.13. Приклад використання операторів &lt;code&gt;break&lt;/code&gt; та &lt;code&gt;continue&lt;/code&gt; у циклах&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  for (int i = 0; i &amp;lt; 10; ++i)
  {
     if (i%3 == 0)
        continue;
     
     Console.Write(i + &amp;quot; &amp;quot;);
     
     if(i%7==0)
        break;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  1 2 4 5 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;chapter522&#34;&gt;5.2.2.Цикли &lt;code&gt;while&lt;/code&gt; та &lt;code&gt;do-while&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;Цикл while у мінімально модифікованому вигляді є частиною
практично усіх мов програмування. Тіло циклу виконується до тих пір,
поки залишається істинною умова &lt;code&gt;while&lt;/code&gt;. Синтаксис оголошення має
вигляд:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  while (умова) { 
      //інструкції 
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Цикл &lt;code&gt;while&lt;/code&gt; може працювати з передумовою та післяумовою. Цикл з передумовою спочатку перевіряє умову, а після цього виконує або не виконує ітерацію циклу. Цикл з післяумовою спочатку виконується
(одна ітерація), а потім тільки перевіряється умова. Таким чином можна
зробити висновок, що цикл з післяумовою виконається мінімум 1 раз.
Синтаксис огололшення циклу &lt;code&gt;while&lt;/code&gt; з післяумовою:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  do 
  { 
      //інструкції 
  } while (умова);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Для порівняння циклів &lt;code&gt;while&lt;/code&gt; розглянемо лістинги 5.14 та 5.15. У
першому випадку не буде виведено на консоль нічого, у другому буде
виведено «5».&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.14. Приклад використання циклу &lt;code&gt;while&lt;/code&gt; з передумовою&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int x = 5;
  while (x &amp;lt; 5)
  {
       Console.Write(x + &amp;quot; &amp;quot;);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 5.15. Приклад використання циклу &lt;code&gt;while&lt;/code&gt; з післяумовою&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int x = 5;
  do
  {
      Console.Write(x + &amp;quot; &amp;quot;);
  } while (x &amp;lt; 5);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Робота з циклом &lt;code&gt;foreach&lt;/code&gt; буде розглянута у розділі 6 разом із вивченням масивів.&lt;/p&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter5samples&#34;&gt;Приклади розв&amp;rsquo;язання задач&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Приклад 5.1.&lt;/strong&gt; Написати програму, яка генерує і виводить на консоль 10 випадкових чисел із діапазону від 10 до 50.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Розв&amp;rsquo;язок:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  Random r = new Random();
  for (int i = 0; i &amp;lt; 10; ++i)
  {
      Console.Write(r.Next(10,50) + &amp;quot;\t&amp;quot;);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Приклад 5.2.&lt;/strong&gt; Написати програму, яка серед 5-ти введених чисел
знаходить найменше. Програма працює наступним чином: користувач
вводить за запитом системи числа, а потім на консоль виводиться
найменше з них.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Розв&amp;rsquo;язок:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int min = int.MaxValue;
  for (int i = 0; i &amp;lt; 5; ++i)
  {
     Console.Write(&amp;quot;Введіть {0} число:\t&amp;quot;, i + 1);
     int num = int.Parse(Console.ReadLine());
     min = num &amp;lt; min ? num : min;
  }
  Console.WriteLine(&amp;quot;Найменше число:\t{0}&amp;quot;,min);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Приклад 5.3.&lt;/strong&gt; Написати програму, що моделює роботу навігації.
Програма повинна пропонувати користувачу вибір дії шляхом введення
символа з клавіатури. Доступними діями є:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;Hello&lt;/code&gt; - виводить на консоль текст «&lt;code&gt;Hello, user!&lt;/code&gt;»&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;Time&lt;/code&gt; - виводить години, хвилини та секунди на поточному ПК&lt;/li&gt;
&lt;li&gt;&lt;input checked=&#34;&#34; disabled=&#34;&#34; type=&#34;checkbox&#34;&gt; &lt;code&gt;Exit&lt;/code&gt; - завершує роботу програми.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Розв&amp;rsquo;язок:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  while (true)
  {
     Console.WriteLine(&amp;quot;\nMake a choice:&amp;quot;);
     Console.Write(&amp;quot; [H]ello\n [T]ime\n E[x]it\n\t\t:&amp;gt;&amp;quot;);
     string res = Console.ReadLine();
     
     switch (res)
     {
       case &amp;quot;H&amp;quot;:
       case &amp;quot;h&amp;quot;:
          Console.WriteLine(&amp;quot;Hello, user!&amp;quot;);
          break;
       case &amp;quot;T&amp;quot;:
       case &amp;quot;t&amp;quot;:
         Console.WriteLine(
         DateTime.Now.ToString(&amp;quot;HH:mm:ss&amp;quot;,
         new CultureInfo(&amp;quot;uk&amp;quot;)));
         break;
       case &amp;quot;X&amp;quot;:
       case &amp;quot;x&amp;quot;:
         return;
         break;
       default:
         Console.WriteLine(&amp;quot;Wrong choice&amp;quot;);
         break;
     }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter5tasks&#34;&gt;Задачі&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.1.&lt;/strong&gt; Написати програму, що знаходить добуток чисел у вказаному
користувачем діапазоні.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.2.&lt;/strong&gt; Дано цілі додатні числа $i$ та $k$ . Реалізувати функцію, що обчислює значення виразу:&lt;/p&gt;
&lt;p&gt;$$
z = i - k, при i кратному k
$$
$$z = k - i, при k кратному i$$
$$z = k + i, при{ }всіх{ }інших{ }умовах$$&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.3.&lt;/strong&gt; Обчислити значення виразу $y=\frac{(x + 5)^3}{\sqrt{x + 1}}$ для усіх $x$ з діапазону $[10; 100]$ кратних $7$-ми. На консоль вивести результат у вигляді, наприклад:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  x   y
  7   125.21
  14  100.41
  ...
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;Примітка. Вивести на консоль не більше двох знаків після розділювача дробової та цілої частини (крапки) для значень $y$.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.4.&lt;/strong&gt; Написати програму, що виводить на консоль таблицю множення на вказане користувачем число. Наприклад, якщо користувач ввів число $5$, то результат виконання програми матиме вигляд:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  5 x 1 = 5
  5 x 2 = 10
  ...
  // і так далі...
  ...
  5 x 10 = 50
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.5.&lt;/strong&gt; Відомо, що $1 дюйм$ рівний $2.54 см$. Розробити додаток, що
переводить дюйми в сантиметри і навпаки. Діалог з користувачем
реалізувати через систему меню.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.6.&lt;/strong&gt; Написати програму, яка виводить на екран лінію з символів.
Число символів та сам символ, і яка буде лінія вертикальна, або
горизонтальна - вказує користувач.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.7.&lt;/strong&gt; Написати програму, що знаходить суму усіх чисел кратних $7$ у діапазоні від $0$ до $100$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.8.&lt;/strong&gt; Написати програму, що обчислює суму цифр введено числа.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.9.&lt;/strong&gt; Написати програму, що виводить на екран цифри введеного числа у зворотному порядку. Наприклад, $248641 &amp;gt; 146842$.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.10.&lt;/strong&gt; Написати програму, дозволяє вивести на консоль в порядку спадання непарні числа із діапазону $[5;90]$, кратні $3$ та не кратні $5$. одночасно.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.11.&lt;/strong&gt; Розробити програму, що працює як найпростіший калькулятор, який виконує арифметичні дії &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;-&lt;/code&gt;, &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;/&lt;/code&gt; (скористатися оператором &lt;code&gt;switch&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.12.&lt;/strong&gt; Знайти найбільший спільний дільник двох натуральних чисел, використавши алгоритм Евкліда. &lt;code&gt;Алгоритм Евкліда полягає в наступному: від більшого числа віднімається менше до тих пір, поки вони не стануть рівними; отримане в результаті число і буде найбільшим спільним дільником.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.13.&lt;/strong&gt; Написати програму, яка виводить на консоль фігури, зображені нижче. &lt;em&gt;Примітка. Розміри фігур вказує користувач.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Фігура 1.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;****************
****************
****************
****************
****************
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Фігура 2.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;****************
*              *
*              *
*              *
****************
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Фігура 3.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;********
******
****
**
*
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-play fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter5solutions&#34;&gt;Рішення до задач&lt;/h2&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-question-circle fa-2x text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4qustions&#34;&gt;Контрольні запитання&lt;/h2&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-book fa-2x text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4sourses&#34;&gt;Список використаних джерел&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Albahari, J., &amp;amp; Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.&lt;/li&gt;
&lt;li&gt;Cardelli, L., &amp;amp; Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з &lt;a href=&#34;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&#34;&gt;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.&lt;/li&gt;
&lt;li&gt;MSDN. (без дати). Отримано з Microsoft Developer Network: &lt;a href=&#34;http://msdn.microsoft.com/&#34;&gt;http://msdn.microsoft.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Биллиг, А. (2005). Основы программирования на C#. Москва, Россия: НОУ ИНТУИТ.&lt;/li&gt;
&lt;li&gt;Нейгел, К. И. (2011). С# 4.0 и платформа .NET 4 для профессионалов. Москва, Россия: ООО &amp;ldquo;И.Д. Вильямс&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Павловская, Т. (2009). С#. Программирование на языке высокого уровня. Учебник для вузов. СПб, Россия: Питер.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-download fa-2x  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter4a&#34;&gt;Додаткові матеріали для завантаження&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі DOCX &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-word  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі PDF &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-pdf  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;Діаграми до лекції у форматі &lt;code&gt;
  &lt;i class=&#34;fas fa-project-diagram  pr-1 fa-fw&#34;&gt;&lt;/i&gt;draw.io&lt;/code&gt; на &lt;code&gt;
  &lt;i class=&#34;fab fa-github  pr-1 fa-fw&#34;&gt;&lt;/i&gt;github&lt;/code&gt; &lt;a href=&#34;https://github.com/kleban/csharp-basics-public/tree/master/diagrams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Перейти&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
    <item>
      <title>Лекція 6. Основи роботи з масивами</title>
      <link>/courses/csharp-basics/lecture6/</link>
      <pubDate>Sat, 17 Apr 2021 00:00:00 +0100</pubDate>
      <guid>/courses/csharp-basics/lecture6/</guid>
      <description>&lt;details class=&#34;toc-inpage d-print-none  &#34; open&gt;
  &lt;summary class=&#34;font-weight-bold&#34;&gt;Table of Contents&lt;/summary&gt;
  &lt;nav id=&#34;TableOfContents&#34;&gt;
  &lt;ul&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter61&#34;&gt;6.1. Поняття масиву даних&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter62&#34;&gt;6.2. Одновимірні масиви&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter621&#34;&gt;6.2.1. Оголошення&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter622&#34;&gt;6.2.2. Ініціалізація&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter63&#34;&gt;6.3. Багатовимірні масиви&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter64&#34;&gt;6.4. Масиви масивів&lt;/a&gt;
      &lt;ul&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter624&#34;&gt;6.5. Цикл foreach та масиви&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter66&#34;&gt;6.6. Сортування масивів [-]&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href=&#34;#chapter67&#34;&gt;6.7. Робота з класом Array [-]&lt;/a&gt;&lt;/li&gt;
      &lt;/ul&gt;
    &lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter6tasks&#34;&gt;Задачі&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter6questions&#34;&gt;Контрольні запитання&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter6sourses&#34;&gt;Список використаних джерел&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a href=&#34;#chapter6additional&#34;&gt;Додаткові матеріали для завантаження&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;
&lt;/nav&gt;
&lt;/details&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter61&#34;&gt;6.1. Поняття масиву даних&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Масив&lt;/strong&gt; задає спосіб організації даних. &lt;strong&gt;Масивом&lt;/strong&gt; називають впорядковану сукупність елементів одного типу.&lt;/p&gt;
&lt;p&gt;Кожен елемент масиву має індекси, що визначають порядок елементів. Число індексів
характеризує розмір масиву. Кожен індекс змінюється в деякому діапазоні &lt;code&gt;[а,b]&lt;/code&gt;. У мові C#, як і в
багатьох інших мовах, індекси задаються цілочисельним типом. Діапазон &lt;code&gt;[а,b]&lt;/code&gt; називається
граничною парою, &lt;code&gt;а&lt;/code&gt; – нижньою межою, &lt;code&gt;b&lt;/code&gt; – верхньою межею. Якщо межі задані константними
виразами, то число елементів масиву відоме у момент його оголошення і йому може бути виділена
пам&amp;rsquo;ять ще на етапі трансляції. Такі масиви називаються статичними. Якщо ж вирази, які задають
межі, залежать від змінних, то такі масиви називаються динамічними, оскільки пам&amp;rsquo;ять їм може
бути відведена лише динамічно в процесі виконання програми, коли стають відомими значення
відповідних змінних. Масиву, як правило, виділяється безперервна область пам&amp;rsquo;яті.&lt;/p&gt;
&lt;p&gt;У мові C++ всі масиви є статичними. У мові C# знято істотне обмеження мови C++ на статичність масивів. Масиви в мові C# є справжніми динамічними масивами. Як наслідок цього масиви відносяться до посилальних типів (&lt;code&gt;Reference&lt;/code&gt;), пам&amp;rsquo;ять їм відводиться динамічно в &amp;ldquo;купі&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;У мові C++ &amp;ldquo;класичних&amp;rdquo; багатовимірних масивів немає. Тут введені одновимірні масиви і масиви
масивів. Останні є загальнішою структурою даних і дозволяють задати не лише багатовимірний куб,
але і порізану, ступінчасту структуру. У мові C# збережені одновимірні масиви і масиви масивів. На додаток до них в мову додані багатовимірні масиви. Динамічні багатовимірні масиви мови C# є потужною, надійною, зрозумілою і зручною структурою даних, яку сміливо можна рекомендувати до вживання не лише професіоналам, але і новачкам, що програмують на C#.&lt;/p&gt;
&lt;p&gt;Після цього короткого огляду давайте перейдемо до більш систематичного вивчення деталей роботи з масивами в C#.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter62&#34;&gt;6.2. Одновимірні масиви&lt;/h2&gt;
&lt;h3 id=&#34;chapter621&#34;&gt;6.2.1. Оголошення&lt;/h3&gt;
&lt;p&gt;У спрощеному вигляді оголошення одновимірного масиву виглядає таким чином:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;тип[] ім’я_змінної;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Увага, на відміну від мови C++ квадратні дужки приписані не до імені змінної, а до типу. Вони є
невід&amp;rsquo;ємною частиною визначення класу, так що запис &lt;code&gt;T[]&lt;/code&gt; слід розуміти як клас одновимірний масив
з елементами типу &lt;code&gt;T&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Що ж до меж зміни індексів, то ця характеристика до класу не відноситься, вона є характеристикою
змінних - екземплярів, кожен з яких є одновимірним масивом зі своїм числом елементів, що
задаються в оголошенні змінної.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] а, b, с;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Найчастіше при оголошенні масиву використовується ім&amp;rsquo;я з ініціалізацією. І знову-таки, як і в разі
простих змінних, можуть бути два варіанти ініціалізації. У першому випадку ініціалізація є явною і
задається константним масивом. Ось приклад:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;double[] x= {5.5, 6.6, 7.7};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Слідуючи синтаксису, елементи константного масиву слід брати у фігурні дужки.
У другому випадку створення і ініціалізація масиву виконується в об&amp;rsquo;єктному стилі з викликом
конструктора масиву. І це найбільш поширена практика оголошення масивів. Наведу приклад:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[] d= new int[5];
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Отже, якщо масив оголошується без ініціалізації, то створюється лише висяче посилання із
значенням void. Якщо ініціалізація виконується конструктором, то в динамічній пам&amp;rsquo;яті створюється
сам масив, елементи якого ініціалізувалися константами відповідного типу, і посилання зв&amp;rsquo;язується з цим масивом. Якщо масив ініціалізувався константним масивом, то в пам&amp;rsquo;яті створюється
константний масив, з яким і зв&amp;rsquo;язується посилання.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;chapter622&#34;&gt;6.2.2. Ініціалізація&lt;/h3&gt;
&lt;p&gt;Ініціалізувати масиви, наприклад, можна наступними способами:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Літералами відповідного типу (лістинг 6.1).&lt;/li&gt;
&lt;li&gt;Випадковими числами (лістинг 6.2).&lt;/li&gt;
&lt;li&gt;Ввести з клавіатури (лістинг 6.3).&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Заповнення масиву літералами може відбуватися наступним чином:&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 6.1. Заповнення одновимірного масиву літералами&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int[] nums = { 99, 10, 100, 18, 78, 23, 63, 9, 87, 49 };
  int[] nums;
  nums = new int[ ] { 99, 10, 100, 18, 78, 23, 63, 9, 87, 49 };
  int[] nums = new int[10] { 99, 10, 100, 18, 78, 23, 63, 9, 87, 49 };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Приклад програми на C#, яка заповнює масив випадковими числами:&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 6.2. Заповнення одновимірного масиву літералами&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int[] array = new int[10];
    
  //Параметр фіксується для відтворюваності результатів
  Random rand = new Random(2021);
    
  for (int i = 0; i &amp;lt; 10; ++i)
  {
    array[i] = rand.Next(0, 100);
    Console.Write(&amp;quot; {0}&amp;quot;, array[i]);
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  54 81 42 92 65 70 42 34 0 51
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Ввести з клавіатури значення масиву можна наступним чином:&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 6.3. Заповнення масиву значеннями, введеними з клавіатури&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  //Додаємо кодування кириличних символів
  Console.OutputEncoding = Encoding.UTF8;
  
  int[] array;
  Console.Write(&amp;quot;\n Введіть розмір масиву &amp;gt;\t&amp;quot;);
  int size = Convert.ToInt32(Console.ReadLine());
  array = new int[size];
  
  for (int i = 0; i &amp;lt; array.Length; ++i)
  {
    Console.Write(&amp;quot; Введіть {0}-й елемент:\t&amp;quot;, i + 1);
    array[i] = Convert.ToInt32(Console.ReadLine());
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Введіть розмір масиву &amp;gt;        4
  Введіть 1-й елемент:   7
  Введіть 2-й елемент:   45
  Введіть 3-й елемент:   8
  Введіть 4-й елемент:   11
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter63&#34;&gt;6.3. Багатовимірні масиви&lt;/h2&gt;
&lt;p&gt;Жодної принципової різниці між одновимірними та багатовимірними масивами немає.&lt;/p&gt;
&lt;p&gt;Одновимірні масиви - це окремий випадок багатовимірних. Можна говорити і по-іншому:
&lt;strong&gt;багатовимірні масиви&lt;/strong&gt; є природним узагальненням одновимірних. Одновимірні масиви дозволяють
задавати такі математичні структури як вектори, двовимірні - матриці, тривимірні - куби даних,
масиви більшої розмірності - багатовимірні куби даних. Варто відмітити, що при роботі з базами даних багатовимірні куби, так звані куби &lt;code&gt;OLAP&lt;/code&gt;, зустрічаються часто.&lt;/p&gt;
&lt;p&gt;От як виглядає оголошення багатовимірного масиву в загальному випадку:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[,] array;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Приклад ініціалізації:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int[,]matrix = {1,2},{3,4};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Давайте розглянемо класичне завдання додавання прямокутних матриць. Нам знадобиться три
динамічні масиви для представлення матриць і три методи, один з яких заповнюватиме вхідні
матриці випадковими числами (&lt;code&gt;FillArray&lt;/code&gt;), інший - виконувати додавання матриць (&lt;code&gt;AddMatrix&lt;/code&gt;), третій - друкувати самі матриці (&lt;code&gt;PrintArray&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Ось тестовий приклад (програма містить трішки довгий код, але варто його переглянути):&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 6.4. Приклад додавання матриць&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  static void Main(string[] args)
  {
      //Оголосимо розмірність наших матриць
      int rows = 3, cols = 5;
  
      //Оголосимо матриці
      int[,] a = new int[rows, cols];
      int[,] b = new int[rows, cols];
      int[,] result = new int[rows, cols];
  
      //Заповнимо матриці випадковими числами
      a = FillArray(rows, cols, 1);
      b = FillArray(rows, cols, 2);
      //Виведемо на консоль матрицю А
      Console.WriteLine(&amp;quot;\nArray1: &amp;quot;);
      PrintArray(a);
      //Виведемо на консоль матрицю B
      Console.WriteLine(&amp;quot;\nArray2: &amp;quot;);
      PrintArray(b);
  
      //Додамо і присвоїмо результат
      result = AddMatrix(a, b);
  
      if (result != null)
      {
          Console.WriteLine(&amp;quot;\nResultMatrix: &amp;quot;);
          PrintArray(result);
      }
  }
  
  static int[,] AddMatrix(int[,] a, int[,] b)
  {
      //Оголосимо матрицю у яку будемо записувати результат.
      int[,] res = new int[a.GetLength(0), a.GetLength(1)];
  
      //Перевіримо чи однаковий розмір матриць
      if ((a.GetLength(0) != b.GetLength(0)) || (a.GetLength(1) != b.GetLength(1)))
          Console.WriteLine(&amp;quot;Мариці неоднакового розміру.&amp;quot;);
      else
      {
          for (int i = 0; i &amp;lt; a.GetLength(0); ++i)
          {
              //Виконуємо додавання елементів матриць
              for (int j = 0; j &amp;lt; a.GetLength(1); ++j)
                  res[i, j] = a[i, j] + b[i, j];
          }
          return res;
      }
      return null;
  }
  
  static int[,] FillArray(int rows, int cols, int seed)
  {
      int[,] array = new int[rows, cols];
      //Створює змінну класу Random для генерування значень
      Random rand = new Random(seed);
  
      for (int i = 0; i &amp;lt; rows; ++i)
      {
          for (int j = 0; j &amp;lt; cols; ++j)
          {
              array[i, j] = rand.Next(0, 100);
          }
      }
      return array;
  }
  
  static void PrintArray(int[,] array)
  {
      for (int i = 0; i &amp;lt; array.GetLength(0); ++i)
      {
          for (int j = 0; j &amp;lt; array.GetLength(1); ++j)
          {
              //Виводимо значення на консоль
              Console.Write(&amp;quot; {0}\t&amp;quot;, array[i, j]);
          }
          Console.WriteLine();
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Array1:
   24      11      46      77      65
   43      35      94      10      64
   2       24      32      98      68
  
  Array2:
   77      40      16      98      10
   30      80      44      22      1
   76      2       0       51      38
  
  ResultMatrix:
   101     51      62      175     75
   73      115     138     32      65
   78      26      32      149     106
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h2 id=&#34;chapter64&#34;&gt;6.4. Масиви масивів&lt;/h2&gt;
&lt;p&gt;Ще одним видом масивів C# є масиви масивів, звані також різаними/рваними масивами (&lt;strong&gt;jagged
arrays&lt;/strong&gt;). Такий масив масивів можна розглядати як одновимірний масив, елементи якого є масивами,
елементи яких, у свою чергу, знову можуть бути масивами, і так може тривати до деякого рівня
вкладеності.&lt;/p&gt;
&lt;p&gt;У яких ситуаціях може виникати необхідність в таких структурах даних? Ці масиви можуть
застосовуватися для представлення дерев, в яких вузли можуть мати довільне число нащадків. Таким
може бути, наприклад, генеалогічне дерево. Вершини першого рівня - &lt;code&gt;Fathers&lt;/code&gt;, що представляють
батьків, можуть задаватися одновимірним масивом, так що &lt;code&gt;Fathers[i]&lt;/code&gt; - це &lt;code&gt;i&lt;/code&gt;-й батько. Вершини
другого рівня представляються масивом масивів - &lt;code&gt;Children&lt;/code&gt;, так що &lt;code&gt;Children[i]&lt;/code&gt; - це масив дітей &lt;code&gt;i&lt;/code&gt;-го батька, а &lt;code&gt;Children[i][j]&lt;/code&gt; - це &lt;code&gt;j&lt;/code&gt;-а дитина &lt;code&gt;i&lt;/code&gt;-го батька. Для представлення внуків знадобиться третій рівень, так що &lt;code&gt;GrandChildren[i][j][k]&lt;/code&gt; представлятиме &lt;code&gt;k&lt;/code&gt;-го внука &lt;code&gt;j&lt;/code&gt;-ї дитини &lt;code&gt;i&lt;/code&gt;-го батька.&lt;/p&gt;
&lt;p&gt;Є деякі особливості в оголошенні і ініціалізації таких масивів. Якщо при оголошенні багатовимірних
масивів для вказівки розмірності використовувалися коми, то для порізаних масивів застосовується
зрозуміліша символіка - сукупності пар квадратних дужок; наприклад, &lt;code&gt;int[][]&lt;/code&gt; задає масив, елементи якого - одновимірні масиви елементів типу &lt;code&gt;int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Складніше зі створенням самих масивів і їх ініціалізацією. Тут не можна викликати конструктор &lt;code&gt;new int[3][5]&lt;/code&gt;, оскільки він не задає порізаний масив. Фактично потрібно викликати конструктор для
кожного масиву на нийнижчому рівні. У цьому і полягає складність оголошення таких масивів.&lt;/p&gt;
&lt;p&gt;Розпочнемо з формального прикладу:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int[][] jagger = new int[3][]
  {
    new int[] {5,7,9,11},
    new int[] {2,8},
    new int[] {6,12,4}
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Масив &lt;code&gt;jagger&lt;/code&gt; має всього два рівні. Можна вважати, що у нього три елементи, кожен з яких є
масивом. Для кожного такого масиву необхідно викликати конструктор &lt;code&gt;new&lt;/code&gt;, аби створити
внутрішній масив. У даному прикладі елементи внутрішніх масивів набувають значення, будучи
явно ініціалізовані константними масивами. Звичайно, допустимим є і таке оголошення:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int[][] jagger1 = new int[3][]
  {
    new int[4],
    new int[2],
    new int[3]
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;В цьому випадку елементи масиву набудуть при ініціалізації нульових значень. Реальну
ініціалізацію потрібно буде виконувати програмним шляхом. Варто відмітити, що в конструкторі
верхнього рівня константу &lt;code&gt;3&lt;/code&gt; можна опустити і писати просто &lt;code&gt;new int[][]&lt;/code&gt;. Також виклик
цього конструктора можна взагалі опустити - він матиметься на увазі:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  int[][] jagger2 =
  {
    new int[4],
    new int[2],
    new int[3]
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Оголошувати вкладені масиви обов’язково.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;chapter624&#34;&gt;6.5. Цикл foreach та масиви&lt;/h3&gt;
&lt;p&gt;У лекції про цикли загдувалося, що у мові С# визначений цикл &lt;code&gt;foreach&lt;/code&gt;, але детальний його розгляд
був відкладений «на потім». Час для нього настав.&lt;/p&gt;
&lt;p&gt;Цикл &lt;code&gt;foreach&lt;/code&gt; використовується для опису елементів колекції. &lt;strong&gt;Колекція&lt;/strong&gt; – це група об&amp;rsquo;єктів. С#
визначає декілька типів колекцій, і одним з них є масив. Формат запису циклу &lt;code&gt;foreach&lt;/code&gt; має такий
вигляд:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  foreach (тип ім&#39;я_змінної in колекція) 
  {
    інструкції;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Тут елементи тип та ім’я_змінної задають тип та ім&amp;rsquo;я ітераційної змінної, яка при функціонуванні
циклу &lt;code&gt;fоreach&lt;/code&gt; набуватиме значень елементів з колекції. Елемент колекція служить для вказівки
опитуваної колекції (в даному випадку як колекцію ми розглядаємо масив). Таким чином, елемент
тип повинен збігатися (або бути сумісним) з базовим типом масиву. Тут важливо запам&amp;rsquo;ятати, що
ітераційну змінну стосовно масиву можна використовувати лише для читання. Отже, неможливо
змінити вміст масиву, присвоївши ітераційній змінній нове значення.&lt;/p&gt;
&lt;p&gt;Розглянемо простий приклад використання циклу &lt;code&gt;foreach&lt;/code&gt;. Приведена нижче програма створює
масив для зберігання цілих чисел і присвоює його елементам початкові значення. Потім вона
відображає елементи масиву, попутно обчислюючи їх суму.&lt;/p&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-code text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; &lt;em&gt;Лістинг 6.5. Робота з циклом foreach&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-csharp&#34;&gt;  Console.OutputEncoding = Encoding.UTF8;
  
  int[] array = new int[10];
  int suma = 0;
  Random r = new Random(2021);
  
  //Заповнюмє масив випадковими числами
  for (int i = 0; i &amp;lt; array.Length; ++i)
      array[i] = r.Next(10, 100);
  
  Console.Write(&amp;quot;Array:\t&amp;quot;);
  foreach (int element in array)
  {
      Console.Write(&amp;quot;{0} &amp;quot;, element);
      suma += element;
  }
  Console.WriteLine(&amp;quot;\n\nСума елементів:\t{0}&amp;quot;, suma);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;
  &lt;i class=&#34;fas fa-play text-muted  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Результат виконання:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  Array:  59 83 48 93 69 73 48 41 10 56

  Сума елементів: 580
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;h3 id=&#34;chapter66&#34;&gt;6.6. Сортування масивів [-]&lt;/h3&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Розділ у процесі наповнення
  &lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;h3 id=&#34;chapter67&#34;&gt;6.7. Робота з класом Array [-]&lt;/h3&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Розділ у процесі наповнення
  &lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-list-alt fa-2x text-success  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter6tasks&#34;&gt;Задачі&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Задача 1.&lt;/strong&gt; Написати програму, яка знаходить суму парних і суму непарних елементів масиву.
Елементи масиву генеруються випадковим чином. Кількість стовпців та рядків вводить користувач.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 2.&lt;/strong&gt; Написати програму, яка знаходить в масиві значення, що повторюються два і більше разів, і показує їх на екран. Елементи масиву генеруються випадковим чином. Кількість стовпців та рядків вводить користувач. Наприклад:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  45  12  12  63
  15  12  45  78
  75  56  89  1
  
  Результат: 12, 75
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 3.&lt;/strong&gt; Написати програму, яка знаходить в масиві найменше непарне число і показує його на
екран. Елементи масиву генеруються випадковим чином. Кількість стовпців та рядків вводить
користувач.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 4.&lt;/strong&gt; Задано масив із $n$ дійсних чисел. Обчислити різницю між максимальним та мінімальним
за модулем елементами цього масиву. Елементи масиву генеруються випадковим чином. Кількість
стовпців та рядків вводить користувач.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 5.&lt;/strong&gt; Дано одновимірний масив із дійсних чисел. Відсортувати його таким чином, щоб всі
додатні елементи знаходилися на початку, а всі від&amp;rsquo;ємні – в кінці, і при цьому зберігся початковий
порядок елементів в обох групах.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 6.&lt;/strong&gt; Задано одновимірний масив. Знайти два серед його елементів, модуль різниці яких має
найменше значення.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 7.&lt;/strong&gt; Сформувати цілочисельний масив, елементами якого є випадкові числа із діапазону.
Знайти суму елементів масиву, значення яких кратні $8$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 8.&lt;/strong&gt; Розробити функцію, що переставляє в зворотному порядку елементи головної діагоналі
квадтаної матриці.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 9.&lt;/strong&gt; Переформатувати марицю (двовимірний масив) таким чином, щоб її рядки розміщувалися за зростанням їх поелементних сум.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 10.&lt;/strong&gt; Знайти мінімальний елемент серед тих елементів масиву $A$, які не є елементами масиву $B$.&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 11.&lt;/strong&gt; Визначити, скільки різних чисел міститься в заданому цілочисельному масиві.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Задача 12.&lt;/strong&gt; Відсортувати рядки двохвимірного масиву за зростанням. Кількість рядків і стовпців вводить користувач. Масив заповнюється випадковими числами із діапазону $[10; 100)$.&lt;/p&gt;
&lt;p&gt;Наприклад:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  45  12  12  63
  15  12  45  78
  75  56  89  1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Результат:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  12  12  45  63
  12  15  45  78
  1   56  75  89
&lt;/code&gt;&lt;/pre&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Задача 13.&lt;/strong&gt; Згенерувати матрицю значень $n*n$ (квадратну). Знайти максимальний елемент у виділеному кольором діапазоні масиву:&lt;/p&gt;
&lt;figure &gt;
&lt;p&gt;&lt;a data-fancybox=&#34;&#34; href=&#34;/media/courses/csharp-basics/lecture6/lecture-6-task-13.svg&#34; &gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;/media/courses/csharp-basics/lecture6/lecture-6-task-13.svg&#34; alt=&#34;&#34;  &gt;
&lt;/a&gt;&lt;/p&gt;
&lt;/figure&gt;
&lt;p&gt;Так, для підзавдання 13.3 і матриці поданої нижче&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  45  12  12  63
  15  12  45  78 
  75  56  89  1
  53  75  78  21
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;максимум становитиме &lt;strong&gt;89&lt;/strong&gt;.&lt;/p&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-question-circle fa-2x text-warning  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter6questions&#34;&gt;Контрольні запитання&lt;/h2&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-book fa-2x text-primary  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter6sourses&#34;&gt;Список використаних джерел&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Albahari, J., &amp;amp; Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.&lt;/li&gt;
&lt;li&gt;Cardelli, L., &amp;amp; Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з &lt;a href=&#34;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&#34;&gt;http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.&lt;/li&gt;
&lt;li&gt;MSDN. (без дати). Отримано з Microsoft Developer Network: &lt;a href=&#34;http://msdn.microsoft.com/&#34;&gt;http://msdn.microsoft.com/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Биллиг, А. (2005). Основы программирования на C#. Москва, Россия: НОУ ИНТУИТ.&lt;/li&gt;
&lt;li&gt;Нейгел, К. И. (2011). С# 4.0 и платформа .NET 4 для профессионалов. Москва, Россия: ООО &amp;ldquo;И.Д. Вильямс&amp;rdquo;.&lt;/li&gt;
&lt;li&gt;Павловская, Т. (2009). С#. Программирование на языке высокого уровня. Учебник для вузов. СПб, Россия: Питер.&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;

  &lt;i class=&#34;fas fa-download fa-2x  pr-1 fa-fw&#34;&gt;&lt;/i&gt;
&lt;h2 id=&#34;chapter6additional&#34;&gt;Додаткові матеріали для завантаження&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі DOCX &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-word  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Лекція у форматі PDF &lt;a href=&#34;&#34;&gt;
  &lt;i class=&#34;fas fa-file-pdf  pr-1 fa-fw&#34;&gt;&lt;/i&gt; Завантажити&lt;/a&gt;&lt;/del&gt; (у розробці)&lt;/li&gt;
&lt;li&gt;Діаграми до лекції у форматі &lt;code&gt;
  &lt;i class=&#34;fas fa-project-diagram  pr-1 fa-fw&#34;&gt;&lt;/i&gt;draw.io&lt;/code&gt; на &lt;code&gt;
  &lt;i class=&#34;fab fa-github  pr-1 fa-fw&#34;&gt;&lt;/i&gt;github&lt;/code&gt; &lt;a href=&#34;https://github.com/kleban/csharp-basics-public/tree/master/diagrams&#34; target=&#34;_blank&#34; rel=&#34;noopener&#34;&gt; Перейти&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;div class=&#34;alert alert-note&#34;&gt;
  &lt;div&gt;
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  &lt;/div&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>
