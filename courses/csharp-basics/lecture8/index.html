<!DOCTYPE html><html lang="uk" >

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  
  
  <meta name="generator" content="Wowchemy 5.0.0-beta.2 for Hugo">
  

  

  
  

  
  
  
  
  
    
    
    
  
  

  <meta name="author" content="Yurii Kleban">

  
  
  
    
  
  <meta name="description" content="Table of Contents  8.1. Поняття об&rsquo;єкта та класу. Основні елементи класу 8.2. Будова класу  8.2.1. Поля класу 8.2.2. Методи класу 8.2.3. Конструктори   8.3. Інкапсуляція  8.">

  
  <link rel="alternate" hreflang="uk" href="/courses/csharp-basics/lecture8/">

  







  




  
  
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  

  
  
  
  <meta name="theme-color" content="#1565c0">
  

  
  
  
  <script src="/js/mathjax-config.js"></script>
  

  
  
  
  
    
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css" integrity="sha256-FMvZuGapsJLjouA6k7Eo2lusoAX9i0ShlWFG6qt7SLc=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css" integrity="sha256-Vzbj7sDDS/woiFS3uNKo8eIuni59rjyNGtXfstRzStA=" crossorigin="anonymous" media="print" onload="this.media='all'">

    
    
    
      
    
    
      
      
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/vs2015.min.css" crossorigin="anonymous" title="hl-light" media="print" onload="this.media='all'">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/vs2015.min.css" crossorigin="anonymous" title="hl-dark" media="print" onload="this.media='all'" disabled>
      
    

    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.css" integrity="sha512-1xoFisiGdy9nvho8EgXuXvnpR5GAMSjFwp40gSRE3NwdUdIMIKuPa7bqoUhLD0O/5tPNhteAsE5XyyMi5reQVA==" crossorigin="anonymous" media="print" onload="this.media='all'">
    

    

    
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.2.2/lazysizes.min.js" integrity="sha512-TmDwFLhg3UA4ZG0Eb4MIyT1O1Mb+Oww5kFG0uHqXsdbyZz9DcvYQhKpGgNkamAI6h2lGGZq2X8ftOJvF/XjTUg==" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    
      

      
      

      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js" integrity="" crossorigin="anonymous" async></script>
      
    
      

      
      

      
    
      

      
      

      
    

  

  
  
  
    
      
      <link rel="preload" as="style" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap">
      <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&family=Roboto+Mono&family=Roboto:wght@400;700&display=swap" media="print" onload="this.media='all'">
    
  

  
  
  
  
  
  <link rel="stylesheet" href="/css/wowchemy.33319bbe33e1b9feff835521b777a249.css">

  




  
<script>
  (function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
  new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
  j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
  'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
  })(window,document,'script','dataLayer','GTM-5SXV7QJ');
</script>


  


  
  

  

  
  <link rel="manifest" href="/index.webmanifest">
  

  <link rel="icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_32x32_fill_lanczos_center_2.png">
  <link rel="apple-touch-icon" type="image/png" href="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_180x180_fill_lanczos_center_2.png">

  <link rel="canonical" href="/courses/csharp-basics/lecture8/">

  
  
  
  
  
  
  
    
    
  
  
  <meta property="twitter:card" content="summary">
  
  <meta property="og:site_name" content="kleban.page">
  <meta property="og:url" content="/courses/csharp-basics/lecture8/">
  <meta property="og:title" content="Лекція 8. Вступ до об&#39;єктно-орієнтовного програмування | kleban.page">
  <meta property="og:description" content="Table of Contents  8.1. Поняття об&rsquo;єкта та класу. Основні елементи класу 8.2. Будова класу  8.2.1. Поля класу 8.2.2. Методи класу 8.2.3. Конструктори   8.3. Інкапсуляція  8."><meta property="og:image" content="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png">
  <meta property="twitter:image" content="/images/icon_hu0b7a4cb9992c9ac0e91bd28ffd38dd00_9727_512x512_fill_lanczos_center_2.png"><meta property="og:locale" content="uk">
  
    
      <meta property="article:published_time" content="2021-04-18T00:00:00&#43;01:00">
    
    <meta property="article:modified_time" content="2021-04-18T00:00:00&#43;01:00">
  

  



  


  


  





  <title>Лекція 8. Вступ до об&#39;єктно-орієнтовного програмування | kleban.page</title>

</head>


<body id="top" data-spy="scroll" data-offset="70" data-target="#TableOfContents" class="page-wrapper  ">

  
  
  
  
  
  
  
  
  <script src="/js/wowchemy-init.min.0475bc389b7599ef6b1889ad17c11742.js"></script>

  

<aside class="search-modal" id="search">
  <div class="container">
    <section class="search-header">

      <div class="row no-gutters justify-content-between mb-3">
        <div class="col-6">
          <h1>Search</h1>
        </div>
        <div class="col-6 col-search-close">
          <a class="js-search" href="#" aria-label="Close"><i class="fas fa-times-circle text-muted" aria-hidden="true"></i></a>
        </div>
      </div>

      <div id="search-box">
        
        <input name="q" id="search-query" placeholder="Search..." autocapitalize="off"
        autocomplete="off" autocorrect="off" spellcheck="false" type="search" class="form-control"
        aria-label="Search...">
        
      </div>

      
      

      

    </section>
    <section class="section-search-results">

      <div id="search-hits">
        
      </div>

    </section>
  </div>
</aside>



  <div class="page-header">
    












<nav class="navbar navbar-expand-lg navbar-light compensate-for-scrollbar" id="navbar-main">
  <div class="container-xl">

    
    <div class="d-none d-lg-inline-flex">
      <a class="navbar-brand" href="/">kleban.page</a>
    </div>
    

    
    <button type="button" class="navbar-toggler" data-toggle="collapse"
            data-target="#navbar-content" aria-controls="navbar" aria-expanded="false" aria-label="Toggle navigation">
    <span><i class="fas fa-bars"></i></span>
    </button>
    

    
    <div class="navbar-brand-mobile-wrapper d-inline-flex d-lg-none">
      <a class="navbar-brand" href="/">kleban.page</a>
    </div>
    

    
    
    <div class="navbar-collapse main-menu-item collapse justify-content-start" id="navbar-content">

      
      <ul class="navbar-nav d-md-inline-flex">
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#about"><span>Demo</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#posts"><span>Posts</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#projects"><span>Проекти</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#talks"><span>Talks</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#featured"><span>Publications</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
        

        <li class="nav-item">
          <a class="nav-link  active" href="/courses/"><span>Курси</span></a>
        </li>

        
        

        

        
        
        
          
        

        

        
        
        
        

        
          
            
            
          
          
            
            
            
              
            
            
          
        

        <li class="nav-item">
          <a class="nav-link " href="/#contact"><span>Contact</span></a>
        </li>

        
        

      

        
      </ul>
    </div>

    <ul class="nav-icons navbar-nav flex-row ml-auto d-flex pl-md-2">

      
      
        
          
          <li class="nav-item d-none d-lg-inline-flex">
            <a class="nav-link" href="https://twitter.com/GeorgeCushen" data-toggle="tooltip" data-placement="bottom" title="Follow me on Twitter" target="_blank" rel="noopener" aria-label="Follow me on Twitter">
              <i class="fab fa-twitter" aria-hidden="true"></i>
            </a>
          </li>
        
      

      
      
      <li class="nav-item">
        <a class="nav-link js-search" href="#" aria-label="Search"><i class="fas fa-search" aria-hidden="true"></i></a>
      </li>
      

      
      

      

    </ul>

  </div>
</nav>


  </div>

  <div class="page-body">
    

<div class="container-fluid docs">
  <div class="row flex-xl-nowrap">
    <div class="col-12 col-md-3 col-xl-2 docs-sidebar">
      





  
    
  




<form class="docs-search d-flex align-items-center">
  <button class="btn docs-toggle d-md-none p-0 mr-3" type="button" data-toggle="collapse" data-target="#docs-nav" aria-controls="docs-nav" aria-expanded="false" aria-label="Toggle section navigation">
    <span><i class="fas fa-bars"></i></span>
  </button>

  
  <input name="q" type="search" class="form-control" placeholder="Search..." autocomplete="off">
  
</form>

<nav class="collapse docs-links" id="docs-nav">
  

  
  
  
    
  

  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/">Про курс</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture1/">1. Вступ до курсу</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture2/">2. Алгоритмізація</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture3/">3. Visual Studio і .NET</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture4/">4. Типи даних, змінні</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture5/">5. Розгалуження та цикли</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture6/">6. Масиви</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture7/">7. Enum &amp; Struct</a>

  </div>
  
  <div class="docs-toc-item active">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecture8/">8. Вступ до ООП</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecturex/">X. Інші теми</a>

  </div>
  
  <div class="docs-toc-item">
    <a class="docs-toc-link" href="/courses/csharp-basics/lecturey/">Y. Рішення до задач</a>

  </div>
  
  
</nav>

    </div>

    
    <div class="d-none d-xl-block col-xl-2 docs-toc">
      <ul class="nav toc-top">
        <li><a href="#" id="back_to_top" class="docs-toc-title">Contents</a></li>
      </ul>

      <nav id="TableOfContents">
  <ul>
    <li><a href="#chapter81">8.1. Поняття об&rsquo;єкта та класу. Основні елементи класу</a></li>
    <li><a href="#chapter82">8.2. Будова класу</a>
      <ul>
        <li><a href="#chapter821">8.2.1. Поля класу</a></li>
        <li><a href="#chapter822">8.2.2. Методи класу</a></li>
        <li><a href="#chapter822">8.2.3. Конструктори</a></li>
      </ul>
    </li>
    <li><a href="#83-інкапсуляція">8.3. Інкапсуляція</a>
      <ul>
        <li><a href="#831-реалізація-інкапсуляції-традиційними-методами-доступу-і-зміни-даних">8.3.1. Реалізація інкапсуляції традиційними методами доступу і зміни даних</a></li>
        <li><a href="#832-друга-форма-інкапсуляції---властивості-класу">8.3.2. Друга форма інкапсуляції - властивості класу</a></li>
        <li><a href="#834-властивості-лише-для-читання-і-лише-для-запису">8.3.4. Властивості лише для читання і лише для запису</a></li>
      </ul>
    </li>
    <li><a href="#84-підтримка-наслідування-у-с">8.4. Підтримка наслідування у С#</a>
      <ul>
        <li><a href="#841-наслідування">8.4.1. Наслідування</a></li>
        <li><a href="#842-ключове-слово-protected">8.4.2. Ключове слово <code>protected</code></a></li>
        <li><a href="#843-запобігання-наслідування---запаковані-класи-sealed">8.4.3. Запобігання наслідування - запаковані класи (sealed)</a></li>
        <li><a href="#844-програмування-включення-делегування">8.4.4. Програмування включення/ делегування</a></li>
        <li><a href="#845-вкладені-визначення-типів">8.4.5. Вкладені визначення типів</a></li>
      </ul>
    </li>
    <li><a href="#85-підтримка-поліморфізму-у-c">8.5. Підтримка поліморфізму у C#</a>
      <ul>
        <li><a href="#851-реалізація-поліморфізму-у-с">8.5.1. Реалізація поліморфізму у С#</a></li>
        <li><a href="#852-ключові-слова-virtual-і-override">8.5.2. Ключові слова <code>virtual</code> і <code>override</code></a></li>
        <li><a href="#853-поняття-абстрактного-класу">8.5.3. Поняття абстрактного класу</a></li>
      </ul>
    </li>
    <li><a href="#презентація">Презентація</a></li>
    <li><a href="#chapter8task">Задачі</a></li>
    <li><a href="#chapter8questions">Контрольні запитання</a></li>
    <li><a href="#chapter8sources">Де почитати?</a></li>
    <li><a href="#chapter8sources">Список використаних джерел</a></li>
    <li><a href="#chapter8additional">Додаткові матеріали для завантаження</a></li>
  </ul>
</nav>

      
    </div>
    

    <main class="col-12 col-md-9 col-xl-8 py-md-3 pl-md-5 docs-content" role="main">

      <article class="article">

        <div class="docs-article-container">
          <h1>Лекція 8. Вступ до об&#39;єктно-орієнтовного програмування</h1>

          <div class="article-style">
            <hr>
<span style="float:right; opacity:0.3">

  <i class="fas fa-atlas fa-3x  pr-1 fa-fw"></i>
</span>
<details class="toc-inpage d-print-none  " open>
  <summary class="font-weight-bold">Table of Contents</summary>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#chapter81">8.1. Поняття об&rsquo;єкта та класу. Основні елементи класу</a></li>
    <li><a href="#chapter82">8.2. Будова класу</a>
      <ul>
        <li><a href="#chapter821">8.2.1. Поля класу</a></li>
        <li><a href="#chapter822">8.2.2. Методи класу</a></li>
        <li><a href="#chapter822">8.2.3. Конструктори</a></li>
      </ul>
    </li>
    <li><a href="#83-інкапсуляція">8.3. Інкапсуляція</a>
      <ul>
        <li><a href="#831-реалізація-інкапсуляції-традиційними-методами-доступу-і-зміни-даних">8.3.1. Реалізація інкапсуляції традиційними методами доступу і зміни даних</a></li>
        <li><a href="#832-друга-форма-інкапсуляції---властивості-класу">8.3.2. Друга форма інкапсуляції - властивості класу</a></li>
        <li><a href="#834-властивості-лише-для-читання-і-лише-для-запису">8.3.4. Властивості лише для читання і лише для запису</a></li>
      </ul>
    </li>
    <li><a href="#84-підтримка-наслідування-у-с">8.4. Підтримка наслідування у С#</a>
      <ul>
        <li><a href="#841-наслідування">8.4.1. Наслідування</a></li>
        <li><a href="#842-ключове-слово-protected">8.4.2. Ключове слово <code>protected</code></a></li>
        <li><a href="#843-запобігання-наслідування---запаковані-класи-sealed">8.4.3. Запобігання наслідування - запаковані класи (sealed)</a></li>
        <li><a href="#844-програмування-включення-делегування">8.4.4. Програмування включення/ делегування</a></li>
        <li><a href="#845-вкладені-визначення-типів">8.4.5. Вкладені визначення типів</a></li>
      </ul>
    </li>
    <li><a href="#85-підтримка-поліморфізму-у-c">8.5. Підтримка поліморфізму у C#</a>
      <ul>
        <li><a href="#851-реалізація-поліморфізму-у-с">8.5.1. Реалізація поліморфізму у С#</a></li>
        <li><a href="#852-ключові-слова-virtual-і-override">8.5.2. Ключові слова <code>virtual</code> і <code>override</code></a></li>
        <li><a href="#853-поняття-абстрактного-класу">8.5.3. Поняття абстрактного класу</a></li>
      </ul>
    </li>
    <li><a href="#презентація">Презентація</a></li>
    <li><a href="#chapter8task">Задачі</a></li>
    <li><a href="#chapter8questions">Контрольні запитання</a></li>
    <li><a href="#chapter8sources">Де почитати?</a></li>
    <li><a href="#chapter8sources">Список використаних джерел</a></li>
    <li><a href="#chapter8additional">Додаткові матеріали для завантаження</a></li>
  </ul>
</nav>
</details>
<hr>
<h2 id="chapter81">8.1. Поняття об&rsquo;єкта та класу. Основні елементи класу</h2>
<p>Об&rsquo;єктно-орієнтоване програмування і проектування побудоване на класах. Будь-яку програмну систему, побудовану в об&rsquo;єктному стилі, можна розглядати як сукупність класів, можливо, об&rsquo;єднаних в проекти, простори імен, рішення, як це робиться при програмуванні у Visual Studio.</p>
<p><strong>Клас</strong> - це шаблон, який визначає форму об&rsquo;єкту. Він задає як дані, так і код, який оперує цими даними.</p>
<p><strong>Об&rsquo;єкти</strong> - це екземпляри класу.</p>
<p>Клас складається із:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> полів;</li>
<li><input checked="" disabled="" type="checkbox"> властивостей;</li>
<li><input checked="" disabled="" type="checkbox"> методів;</li>
<li><input checked="" disabled="" type="checkbox"> подій;</li>
<li><input checked="" disabled="" type="checkbox"> конструкторів;</li>
<li><input checked="" disabled="" type="checkbox"> деструкторів;</li>
<li><input checked="" disabled="" type="checkbox"> делегатів.</li>
<li><input checked="" disabled="" type="checkbox"> &hellip;</li>
</ul>
<p>Елементи класу називаються членами класу.</p>
<p>Клас оголошується за допомогою ключового слова <code>class</code>. Синтаксис має наступний вигляд:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.1. Синтаксис оголошення класу.</p>
<pre><code class="language-{csharp}">  class ім’я_класу
  {
    //Оголошення полів
    доступ тип імя_змінної;
    доступ тип імя_змінної;
  
    //Оголошення методів
    доступ тип_повернення імя_метода(параметри)
    {
      тіло метода;
    }
  
    доступ тип_повернення імя_метода(параметри)
    {
      тіло метода;
    }
  }
</code></pre>
<p>Розглянемо приклад базового створення класу &ldquo;Комплексне число&rdquo;.</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.2. Оголошення класу <code>ComplexNumber</code>.</p>
<pre><code class="language-{csharp}">  public class ComplexNumber
  {
    //Поля
    private double a;
    private double b;
  
    //Конструктор
    public ComplexNumber(double a, double b)
    {
      this.a = a;
      this.b = b;
    }
  
  //Метод
    public override string ToString()
    {
      return a + &quot; + &quot; + b + &quot;i&quot;;
    }
  }
</code></pre>
<p>Доступ до полів, методів та інших членів класу може здійснюватися з різним рівнем доступу:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> <code>private</code> доступний лише всередині класу (типу);</li>
<li><input checked="" disabled="" type="checkbox"> <code>protected</code> доступний лише всередині класу та класів-нащадків;</li>
<li><input checked="" disabled="" type="checkbox"> <code>internal</code> доступний лише в межах збірки;</li>
<li><input checked="" disabled="" type="checkbox"> <code>protected internal</code> доступний лише в межах збірки, лише всередині класу та класів-нащадків;</li>
<li><input checked="" disabled="" type="checkbox"> <code>public</code> доступний для усіх.</li>
</ul>
<hr>
<h2 id="chapter82">8.2. Будова класу</h2>
<h3 id="chapter821">8.2.1. Поля класу</h3>
<p>Поля класу синтаксично є звичайними змінними (об&rsquo;єктами) мови. Їх опис задовольняє звичайним правилам оголошення змінних, про що детально говорилося раніше. Змістовно поля задають представлення тій самій абстракції даних, яку реалізує клас.</p>
<p>Поля характеризують властивості об&rsquo;єктів класу. Коли створюється новий об&rsquo;єкт класу, то цей об&rsquo;єкт є набором полів класу. Два об&rsquo;єкти одного класу мають один і той же набір полів, але різняться значеннями, що зберігаються в цих полях.</p>
<p>Синтаксис оголошення полів:</p>
<pre><code class="language-{csharp}">  модифікатор_доступу тип назва;
</code></pre>
<p>Наприклад, оголосимо клас <code>Worker</code>, який має 3 поля: розмір з/п, прізвище, вік.</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.3. Оголошення полів класу <code>Worker</code>.</p>
<pre><code class="language-{csharp}">  class Worker
  {
    public double salary;         //Розмір з/п
    public string firstname;   //Ім'я
    public string lastname;    //Прізвище
  }
</code></pre>
<p>Зараз клас працівник нагадує структуру! І це не дивно, адже клас є більш розвиненою структурую.</p>
<hr>
<h3 id="chapter822">8.2.2. Методи класу</h3>
<p>Змінні(поля) екземплярів і методи - дві основні складові класів. Поки наш клас <code>Worker</code> містить лише дані. Хоча такі класи (без методів) допустимі, більшість класів мають методи.</p>
<p><strong>Методи</strong> - це процедури (підпрограми), які маніпулюють даними, визначеними в класі, і у багатьох випадках забезпечують доступ до цих даних. Зазвичай різні частини програми взаємодіють з класом за допомогою його методів. Будь-який метод містить одну або декілька інструкцій.</p>
<p>Кожен метод має ім&rsquo;я, і саме це ім&rsquo;я використовується для його виклику. У загальному випадку методу можна привласнити будь-яке ім&rsquo;я. Але пам&rsquo;ятаєте, що ім&rsquo;я <code>Main()</code> зарезервовано для методу, з якого починається виконання програми. Крім того, як імена методів не можна використовувати ключові слова С#.</p>
<p>Імена методів супроводжуються парою круглих дужок. Наприклад, якщо метод має ім&rsquo;я <code>GetVal</code>, то в тексті буде написано <code>GetVal()</code>. Це допомагає відрізняти імена змінних від імен методів. Формат запису методу такий:</p>
<pre><code class="language-{csharp}">  доступ тип_повернення імя_метода(параметри)
  {
    тіло метода;
  }
</code></pre>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.4. Оголошення класу <code>Worker</code>. Метод.</p>
<pre><code class="language-{csharp}">  class Worker
  {
    public double salary;         //Розмір з/п
    public string firstname;   //Ім'я
    public string lastname;    //Прізвище
  
    //Метод, виводить інформацію про працівника на консоль
    public void DisplayInfo()
    {
      Console.WriteLine(&quot;{0} {1}, - {2} грн.&quot;, lastname, firstname, salary);
    }
  }
</code></pre>
<p>Зверніть увагу ось на що. Змінні екземпляра <code>salary</code>, <code>lastname</code> і <code>firstname</code> використовуються всередині методу <code>DisplayInfo()</code> без будь-яких атрибутів, тобто їм не передує ні ім&rsquo;я об&rsquo;єкту, ні оператор &ldquo;крапка&rdquo;. Це дуже важливий момент: якщо метод задіює змінну екземпляра, яка визначена в його класі, він робить це безпосередньо, без явного посилання на об&rsquo;єкт і без оператора &ldquo;крапка&rdquo;. І Це логічно. Адже метод завжди викликається для деякого об&rsquo;єкту конкретного класу. Таким чином, немає необхідності вказувати усередині методу об&rsquo;єкт удруге. Це означає, що значення <code>salalry</code>, <code>lastname</code> і <code>firstname</code> всередині методу <code>DisplayInfo()</code> неявно вказують на копії цих змінних, що належать об&rsquo;єкту, який викликає метод <code>DisplayInfo()</code>.</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.5. Інші приклади методів</p>
<pre><code class="language-{csharp}">  public int GetAge() {...}
  protected string GetByName(string name) {...}
  protected static bool IsEquals(Class obj1, Class obj2) {...}
</code></pre>
<p><strong>Повернення значення методом.</strong></p>
<p>У загальному випадку існує два варіанти умов для повернення з методу. Перший пов&rsquo;язаний з виявленням закриваючої фігурної дужки, що позначає кінець тіла методу (як продемонстровано на прикладі методу <code>DisplayInfo()</code>). Другий варіант полягає у виконанні інструкції return. Можливі дві форми використання інструкції <code>return</code>: одна призначена для void-методів (які не повертають значень), а інша - для повернення значень.</p>
<p>Негайне завершення <code>void</code>-методу можна організувати за допомогою наступної форми інструкції <code>return</code>:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.5. Інші приклади методів</p>
<pre><code class="language-{csharp}">  public void DisplayInfo()
  {
    if(salary &lt; 0)
      return;
    Console.WriteLine(&quot;{0} {1}, {2}&quot;, lastname, firstname, salary);
  }
</code></pre>
<p>Хоча <code>void</code>-методи - не рідкість, більшість методів все ж повертають значення. І справді, здатність повертати значення - одна з найкорисніших якостей методу. Ми вже розглядали приклад повернення значення під час роботи з масивами. Значення, які повертаються методами, використовуються в програмуванні по різному. У одних випадках повернене значення є результатом обчислень, в інших - воно просто означає, успішно чи ні виконана певна операція, а в третіх - воно може бути кодом-стану. Методи повертають викликаючим їх процедурам, використовуючи наступну форму інструкції <code>return</code>:</p>
<pre><code>return значення;
</code></pre>
<p>Додамо до нашого класу Працівник ще кілька полів і методів.</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.6. Клас &ldquo;Працівник&rdquo;. Методи. Продовження.</p>
<pre><code class="language-{csharp}">  class Worker
  {
      public string firstname;   //Ім'я
      public string lastname;    //Прізвище
      public double salary;         //Розмір з/п
      public double bonus;       //Бонус до з/п у % від з/п
  
      //Метод, виводить інформацію про працівника на консоль
      public void DisplayInfo()
      {
          Console.WriteLine(&quot;{0} {1}, - {2} грн.&quot;, lastname, firstname, salary);
      }
      //Повертає суму бонусу, яку отримає працівник.
      public double GetBonusSum()
      {
          return bonus * salary;
      }
      //Повертає повну суму, яку отримає працівник.
      public double GetFullSum()
      {
          return salary + GetBonusSum();
      }
  }
</code></pre>
<p>У цьому прикладі створено поле «бонус» та три додаткових методи, функціональність яких подана у коментарях. Розглянемо приклад програми:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.7. Приклад роботи з класом &ldquo;Працівник&rdquo;.</p>
<pre><code class="language-{csharp}">  static void Main(string[] args)
  {
    Console.OutputEncoding = Encoding.Unicode;
    Worker worker1 = new Worker();
    worker1.salary = 250;
    worker1.firstname = &quot;Петро&quot;;
    worker1.lastname = &quot;Петров&quot;;
    worker1.bonus = 0.12;
    Console.WriteLine(&quot;Розмір бонусу: {0}\nВсього з/п: {1}&quot;,worker1.GetBonusSum(), worker1.GetFullSum());
  }
</code></pre>
<p>або</p>
<pre><code class="language-{csharp}">  static void Main(string[] args)
  {
    Console.OutputEncoding = Encoding.Unicode;
    Worker worker1 = new Worker();
    worker1.salary = 250;
    worker1.firstname = &quot;Петро&quot;;
    worker1.lastname = &quot;Петров&quot;;
    worker1.bonus = 0.12;
       
    double bonusSum = worker1.GetBonusSum();
    double fullSum = worker1.GetFullSum();
      
    Console.WriteLine(&quot;Розмір бонусу: {0}\nВсього з/п: {1}&quot;,bonusSum,fullSum);
  }
</code></pre>
<p>Результат виконання:</p>
<pre><code>Розмір бонусу: 30
Всього з/п: 280
</code></pre>
<p>Як бачимо, результат виконання для обох програм ідентичний. Функції <code>GetBonusSum()</code> та <code>GetFullSum()</code> повертають значення типу <code>double</code> та передають його у першому випадку одразу для виведення на консоль, у другому записують у проміжні змінні. Аналогічні повернення типів даних можна виконувати для усіх типів даних, як базових так і створених користувачем.</p>
<p><strong>Використання параметрів</strong></p>
<p>Під час виклику методу можна передати одне або декілька значень. Значення, яке передається методу, називається аргументом. Змінна всередині методу, яка набуває значення аргументу, називається параметром. Параметри оголошуються всередині круглих дужок, які слідують за ім&rsquo;ям методу. Синтаксис оголошення параметрів аналогічний синтаксису, вживаному для змінних.</p>
<p>Наприклад, ми можемо визначати суму бонусу, передаючи процент бонусу від з/п у функцію і не записуючи бонус як окреме поле, оскільки є багато працівників, які можуть взагалі не отримати бонус.</p>
<pre><code class="language-{csharp}">  public double GetBonusSum(double bonusPercent)
  {
    return bonusPercent*salary;
  }
</code></pre>
<p>Тоді виклик буде мати вигляд:</p>
<pre><code class="language-{csharp}">worker1.GetBonusSum(0.12);
</code></pre>
<p>У метод можна передавати безліч аргументів різного типу.</p>
<hr>
<h3 id="chapter822">8.2.3. Конструктори</h3>
<p>У попередніх прикладах змінні кожного об’єкта встановлювалися &ldquo;вручну&rdquo; за допомогою наступної послідовності інструкцій:</p>
<pre><code class="language-{csharp}">  worker1.salary = 250;
  worker1.firstname = &quot;Петро&quot;;
  worker1.lastname = &quot;Петров&quot;;
</code></pre>
<p>Професіонал ніколи б не використав подібний підхід. І річ не стільки в тому, що таким чином можна просто &ldquo;забути&rdquo; про одне або декілька полів, скільки в тому, що існує набагато зручніший спосіб це зробити. Цей спосіб - використання конструктора.</p>
<p>Конструктор ініціалізує об&rsquo;єкт при його створенні. Він має таке ж ім&rsquo;я, що і сам клас, а синтаксично подібний до методу. Проте у визначенні конструкторів не вказується тип значення, що повертається. Формат запису конструктора такий:</p>
<pre><code class="language-{csharp}">  доступ імя_класу() 
  {
    // тіло конструктора
  }
</code></pre>
<p>Зазвичай конструктор використовується, аби додати змінним екземпляра, визначеним у класі, початкові значення або виконати вихідні дії, необхідні для створення повністю сформованого об&rsquo;єкту. Крім того, зазвичай як елемент «доступ» використовується модифікатор доступу public, оскільки конструктори, як правило, викликаються поза їх класом.</p>
<p>Всі класи мають конструктори незалежно від того, визначите ви їх чи ні, оскільки С# автоматично надає конструктор за замовчуванням, який ініціалізував всі змінні-члени, що мають типи-значення, нулями, а змінні-члени посилального типу - <code>null</code>-значеннями.</p>
<p>Отже створимо конструктор для класу Worker:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.8. Приклад роботи з класом &ldquo;Працівник&rdquo;. Конструктор</p>
<pre><code class="language-{csharp}">  class Worker
  {
      public string firstname;   //Ім'я
      public string lastname;    //Прізвище
      public double salary;      //Розмір з/п
      public double bonus;       //Бонус до з/п у % від з/п
  
      //Конструктор класу Worker
      public Worker()
      {
          firstname = &quot;empty&quot;;
          lastname = &quot;empty&quot;;
          salary = 0.0;
          bonus = 0.0;
      }
  
      //Перевантажений конструктор класу Worker
      public Worker(string fname, string lname, double salary, double bonus)
      {
          firstname = fname;
          lastname = lname;
          this.salary = salary;
          this.bonus = bonus;
      }
  
      //Метод, виводить інформацію про працівника на консоль
      public void DisplayInfo()
      {
          Console.WriteLine(&quot;{0} {1}, - {2} грн.&quot;, lastname, firstname, salary);
      }
      //Повертає суму бонусу, яку отримає працівник.
      public double GetBonusSum()
      {
          return bonus * salary;
      }
      //Повертає повну суму, яку отримає працівник.
      public double GetFullSum()
      {
          return salary + GetBonusSum();
      }
  }
</code></pre>
<p>Як бачимо, створено два конструктори! Перший (public Worker()) не приймає значень, другий (public Worker(string fname, string lname, double salary, double bonus)) є параметризованим, тобто приймає значення.
Створення двох методів з однаковими іменами, але різними сигнатурами називається перевантаженням методів. Сигнатурою методу є тип повертаємого значення та перелік параметрів. Аналогічно можна перевантажувати конструктори. Детальніше перевантаження методів ми розглянемо під час вивчення наслідування.
Тепер програма маттиме вигляд:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.9. Приклад роботи з класом &ldquo;Працівник&rdquo;. Конструктор. Приклад</p>
<pre><code class="language-{csharp}">  Console.OutputEncoding = Encoding.Unicode;
  Worker worker1 = new Worker();
  worker1.DisplayInfo();
  Worker worker2 = new Worker(&quot;Степан&quot;, &quot;Петров&quot;, 25.5, 0.5);
  worker2.DisplayInfo();
</code></pre>
<p>Результат:</p>
<pre><code>  empty empty, - 0 грн.
  Петров Степан, - 25.5 грн.
</code></pre>
<hr>
<h2 id="83-інкапсуляція">8.3. Інкапсуляція</h2>
<h3 id="831-реалізація-інкапсуляції-традиційними-методами-доступу-і-зміни-даних">8.3.1. Реалізація інкапсуляції традиційними методами доступу і зміни даних</h3>
<p>Інкапсуляція у програмуванні це приховування внутрішньої реалізації та даних класу від зовнішнього доступу. Зазвичай це відбувається закриванням полів за допомогою модифікатора <code>private</code> та доступом до них через методи.</p>
<p>Продовжимо розвивати попередні приклади&hellip;</p>
<p>Якщо ви хочете, аби зовнішній світ міг взаємодіяти із закритим полем даних <code>salary</code>, потрібно визначити метод доступу (<code>get</code>) і метод зміни (<code>set</code>). Наприклад:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.10. Реалізація інкапсуляції у класі &ldquo;Працівник&rdquo;. Методи</p>
<pre><code class="language-{csharp}">  class Worker
  {
      private string firstname;   //Ім'я
      private string lastname;    //Прізвище
      private double salary;      //Розмір з/п
      private double bonus;       //Бонус до з/п у % від з/п
  	  ...
  	  ...
      public double GetSalary()
      {
          return salary;
      }
      
      public void SetSalary(double s)
      {
  	      //здійснити перевірки
          salary = s;
      }
  }
</code></pre>
<p>Тепер за допомогою методів <code>GetSalary()</code> та <code>SetSalary()</code> ми можемо маніпулювати змінною <code>salary</code> всередині класу. Назвати ваші методи ви можете і по іншому, адже це просто методи, проте бажано робити їх назви відповідно до функцій. Тоді виклик у коді програми матиме наступний вигляд:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.11. Реалізація інкапсуляції у класі &ldquo;Працівник&rdquo;</p>
<pre><code class="language-{csharp}">  Worker worker2 = new Worker(&quot;Степан&quot;, &quot;Петров&quot;, 25.5,0.5);
  Console.WriteLine(&quot;Salary: {0}&quot;,worker2.GetSalary());
  worker2.SetSalary(150.6);
  Console.WriteLine(&quot;Salary: {0}&quot;, worker2.GetSalary());
</code></pre>
<p>Результат:</p>
<pre><code>  Salary: 25.5
  Salary: 150.6
</code></pre>
<hr>
<h3 id="832-друга-форма-інкапсуляції---властивості-класу">8.3.2. Друга форма інкапсуляції - властивості класу</h3>
<p>На противагу традиційним методам доступу і зміни в <code>.NET</code>-мовах інкапсуляцію переважно реалізовують за допомогою властивостей, які моделюють відкриті поля даних. Замість того аби заставляти користувача викликати два різні методи для отримання і зміни даних стану, користувач може викликати те, що здається відкритим полем. Для ілюстрації розглянемо властивість <code>Salary</code>, яка замінить два наші методи <code>GetSalary()</code> та <code>SetSalary()</code>.</p>
<p>Синтаксис оголошення властивості:</p>
<pre><code>  доступ тип_повертаємого_ значення назва
  {
  	get{return змінна(поле);}
  	set{змінна(поле) = value;}
  }
</code></pre>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.12. Реалізація інкапсуляції у класі &ldquo;Працівник&rdquo;. Властивості</p>
<pre><code class="language-{csharp}">class Worker
{
    private string firstname;   //Ім'я
    private string lastname;    //Прізвище
    private double salary;      //Розмір з/п

	  ...

    public double Salary
    {
        get { return salary; }
        set { salary = value; }
    }
}
</code></pre>
<hr>
<h3 id="834-властивості-лише-для-читання-і-лише-для-запису">8.3.4. Властивості лише для читання і лише для запису</h3>
<p>При створенні класів ви можете налаштувати властивість доступну лише для запису або лише для читання. Щоб це зробити, просто створіть властивість без відповідного блоку <code>set</code> або <code>get</code>. 
Наприклад, властивість тільки для читання:</p>
<pre><code class="language-{csharp}">  public double Salary
  {
      get { return salary; }
  }
</code></pre>
<p>Властивість тільки для запису:</p>
<pre><code>  public double Salary
  {
      set { salary = value; }
  }
</code></pre>
<hr>
<h2 id="84-підтримка-наслідування-у-с">8.4. Підтримка наслідування у С#</h2>
<h3 id="841-наслідування">8.4.1. Наслідування</h3>
<p>Тепер, коли ми познайомилися з різними способами створення інкапсульованого класу, настав час звернути свою увагу на створення сімейства зв&rsquo;язаних класів.</p>
<p>Як вже наголошувалося, наслідування - це той аспект ООП, який сприяє багатократному використанню коду. 
Наслідування — метод утворення нових класів на основі використання вже існуючих. Наслідування буває двох типів: класичне наслідування (відношення «є») і наслідування відповідно до моделі включения/делегування (відношення «має»).</p>
<p>Давайте почнемо з дослідження класичної моделі «є».</p>
<p>При створенні між класами відношення «є» ви створюєте залежність між типами. Основна ідея класичного наслідування полягає у тому, що нові класи можуть використовувати (і можливо розширювати) функціональність інших класів. Для ілюстрації припустимо, що ви хочете задіювати функціональність класу Worker для створення двох нових класів: <code>SalesPerson</code> (торгівельний агент) і <code>Manager</code> (менеджер). В цьому випадку ієрархія класів виглядатиме так, як показано на малюнку нижче.</p>
<div class="mermaid">
classDiagram
    Worker <|-- Manager
    Worker <|-- SalesManager
</div>
<center><small>Рис. 1. Ієрархія класів Worker, Manager, SalesManager</small></center>
<p>Як показано на рис. 1, торгівельний агент «є» співробітником (так само як і менеджер). У класичній моделі наслідування базові класи (такі як <code>Worker</code>) використовуються для визначення загальних характеристик всіх наслідників. Підкласи (такі як <code>SalesPerson</code> і <code>Manager</code>) розширюють цю загальну функціональність, додаючи більш специфічну поведінку.</p>
<p>Для нашого прикладу припустимо, що клас Manager розширює клас <code>Worker</code>, додаючи запис про кількість акцій, якими володіє співробітник, а клас <code>SalesPerson</code> містить обсяги продажів, здійснені цим агентом. У С# розширення класу виконується за допомогою оператора <code>:</code> (двокрапка) у визначенні класу.</p>
<p>Тоді похідний клас «Торговий агент» матиме наступний вигляд:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.13. Реалізація класу &ldquo;SalesManager&rdquo;</p>
<pre><code class="language-{csharp}">  class SalesPerson : Worker
  {
      private double salesQuantity;
      public double SalesQuantity
      {
          get { return salesQuantity; }
          set { salesQuantity = value; }
      }
  }
</code></pre>
<p>Проте, як видно з прикладу, немає конструткора, який би передавав інформацію про агента для класу. Тому розширимо клас і додамо конструтор:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.14. Реалізація класу &ldquo;SalesManager&rdquo;. Властивість SalesQuantity</p>
<pre><code class="language-{csharp}">  class SalesPerson : Worker
  {
      private double salesQuantity;
      public SalesPerson(string fname, string lname, double salary, double bonus, double sQuantity)
          : base(fname, lname, salary, bonus)
      {
          salesQuantity = sQuantity;
      }
      public double SalesQuantity
      {
          get { return salesQuantity; }
          set { salesQuantity = value; }
      }
  }
</code></pre>
<p>Розберемо код:</p>
<ol>
<li>
<p>Наслідування здіснюється за домогою оператора <code>:</code> (двокрапка)</p>
</li>
<li>
<p>Наслідуватися можна одночасно лише від одного класу та багатьох інтерфейсів.</p>
</li>
<li>
<p>Ми не створюємо полів <code>firstname</code>, <code>lastname</code>, <code>salary</code> і так далі, всі вони неявно наслідуються від базового класу Worker;</p>
</li>
<li>
<p>У конструктор ми передаємо всю ту ж саму інформацію яку передавали для конструктора <code>Worker</code> + наше нове поле <code>salesQuantity</code>.</p>
</li>
<li>
<p>За допомогою ключовго слова base викликаємо конструктор базовго класу і передаємо йому параметри.</p>
</li>
<li>
<p>Використовуємо властивість для доступу до інформації про обсяги продаж.</p>
</li>
</ol>
<p>Реалізуємо у класі Worker властивості для усіх полів і визначимо метод, який дозволить виводити усю інформацію про працівника на екран:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.15. Реалізація класу &ldquo;Worker&rdquo;. Властивості</p>
<pre><code class="language-{csharp}">  public double Salary
  {
      get { return salary; }
      set { salary = value; }
  }
  public string FirstName
  {
      get { return firstname; }
      set { firstname = value; }
  }
  public string LastName
  {
      get { return lastname; }
      set { lastname = value; }
  }
  
  public double Bonus
  {
      get { return bonus; }
      set
      {
          if (bonus &gt;= 0 &amp;&amp; bonus &lt; 1)
              bonus = value;
      }
  }
</code></pre>
<p>Тепер напишемо наступну програму:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.15. Приклад роботи з класом <code>SalesPerson</code></p>
<pre><code class="language-{csharp}">  Console.OutputEncoding = Encoding.Unicode;
  
  SalesPerson sPerson = new SalesPerson(&quot;Петро&quot;, &quot;Петренко&quot;, 125, 0.21, 154);
  sPerson.FirstName = &quot;Остап&quot;;
  sPerson.DisplayInfo();
</code></pre>
<p>Результат</p>
<pre><code>Петренко Остап - 125 грн.
</code></pre>
<p>У нашому класі <code>SalesPerson</code> немає явно реалізованого методу <code>DisplayInfo()</code> або властивості <code>FirstName</code>, проте ми їх можеми викликати! Тобто ми їх успадкували від батьківського класу <code>Worker</code>.</p>
<p>Майте на увазі, що при наслідуванні інкапсуляція зберігається. Тому похідний клас не може безпосередньо звертатися до закритих членів, визначених в його базовому класі. Тобто не можна наприклад у конструкторі класу <code>SalesPerson</code> записати:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.16. Приклад роботи з класом <code>SalesPerson</code></p>
<pre><code class="language-{csharp}">public SalesPerson(string fname, string lname, double salary, double bonus, double sQuantity) 
            : base(fname,lname,salary,bonus)
{
		//Не можна присвоїти значення.
    firstname = fname; //Помилка
    salesQuantity = sQuantity; //Помилка
} 
</code></pre>
<p>Нагадаємо, що усі поля класі Worker приватні (<code>private</code>), тобто закриті від «зовнішнього світу».</p>
<hr>
<h3 id="842-ключове-слово-protected">8.4.2. Ключове слово <code>protected</code></h3>
<p>Як ви вже знаєте, відкриті елементи безпосередньо доступні звідки завгодно, тоді як до закритих елементів не можна дістати доступ з якого-небудь об&rsquo;єкту, окрім класу, що визначив їх. С# наслідує приклад багатьох інших сучасних об&rsquo;єктно-орієнтованих мов і надає додатковий рівень доступу - захищений (<code>protected</code>) доступ.</p>
<p>Коли базовий клас визначає захищені дані або члени, він створює множину елементів, які можуть бути безпосередньо доступні будь-якому насліднику. Якщо ви хочете дозволити класам <code>SalesPerson</code> і Manager безпосередньо звертатися до даних, визначених в класі <code>Worker</code>, початкове визначення класу Worker можна змінити таким чином:</p>
<p>
  <i class="fas fa-code text-success  pr-1 fa-fw"></i> Лістинг 8.17. Оголошення класу <code>Worker</code>. Поля</p>
<pre><code class="language-{csharp}">class Worker
{
  protected string firstname;   //Ім'я
  protected string lastname;    //Прізвище
  protected double salary;      //Розмір з/п
  protected double bonus;       //Бонус до з/п у % від з/п
}
</code></pre>
<p>Після цього конструкція <code>firstname = fname</code>; стане доступною і програма відкомпілюється.</p>
<p>Перевага визначення захищених членів в базовому класі полягає в тому, що похідним класам більше не доведеться діставати доступ до даних за допомогою відкритих методів або властивостей. Вочевидь, є і негатив: коли похідний клас має безпосередній доступ до внутрішніх даних його батьківського класу, існує можливість неумисного обходу бізнес-правил, визначених у відкритих властивостях. При визначенні захищених членів ви створюєте певний рівень довіри між батьківським і дочірнім класом, оскільки компілятор не намагатиметься виявляти які-небудь порушення бізнес-правил. І нарешті, знайте, що з точки зору користувача об&rsquo;єкту захищені дані вважаються закритими (оскільки користувач знаходиться «поза родинним колом»).</p>
<p>Тому наступний код недопустимий:</p>
<pre><code class="language-{csharp}">SalesPerson sPerson = new SalesPerson(&quot;Петро&quot;, &quot;Петров&quot;,125, 0.21, 154);
sPerson.firstname = &quot;Іван&quot;; // Помилка
sPerson.DisplayInfo();
</code></pre>
<hr>
<h3 id="843-запобігання-наслідування---запаковані-класи-sealed">8.4.3. Запобігання наслідування - запаковані класи (sealed)</h3>
<p>При створенні відношень базовий клас/підклас можна використовувати поведінку існуючих типів. Проте що якщо ви хочете визначити клас, від якого не можна створювати похідні класи? Наприклад, припустимо, що ви додали ще один клас в простір імен, який розширює існуючий тип <code>SalesPerson</code>. На рис. 2. показана зміна ієрархії.</p>
<div class="mermaid">
classDiagram
    Worker <|-- Manager
    Worker <|-- SalesManager
    SalesManager <|-- PSalesPerson
</div>
<center><small>Рис. 2. Ієрархія класів Worker, Manager, SalesManager, PSalesPerson</small></center>
<p>Класом, що представляє торгівельного агента, що працює за сумісництвом, є PSalesPerson. Припустимо, що нам потрібно гарантувати, що ніхто не зможе створити підклас від <code>PSalesPerson</code>. Аби цей клас не можна було розширювати, в С# використовується ключове слово <code>sealed</code>:</p>
<pre><code>  sealed class PSalesPerson: SalesPerson
  {
      //Поля
      //Властивості
      //Методи
      public PSalesPerson(string fname, string lname, double salary, double bonus, double sQuantity) 
            : base(fname, lname, salary, bonus, sQuantity)
      {
		    //Інструкції конструктора
      }
  }
</code></pre>
<p>Оскільки клас <code>PSalesPerson</code> запечатано, він не може служити базовим класом для інших типів. Отже якщо спробувати розширити <code>PSalesPerson</code>, ви отримаєте помилку компіляції:</p>
<pre><code>  class PPSalesPerson: PSalesPerson {}
</code></pre>
<h3 id="844-програмування-включення-делегування">8.4.4. Програмування включення/ делегування</h3>
<p>Як наголошувалося раніше, наслідування буває двох видів. Тільки що ми розглянули класичне відношення «є». Аби завершити дослідження цього другого стовпа ООП, давайте дослідимо відношення «має» (відоме так само, як модель включення/делегування). Припустимо, що ми створили новий клас, що моделює соціальний пакет співробітника:</p>
<pre><code>  class SocialPackage
  {
      //Сума виплати
      private double socialSum;

      public double SocialSum
      {
          get { return socialSum; }
          set { socialSum = value; }
      }
  }
</code></pre>
<p>Вочевидь, було б досить дивним встановлювати відношення «є» між соціальним пакетом (класом <code>SocialPackage</code>) і посадами співробітників. (Менеджер «є» соціальним пакетом? Сумнівно).) Проте повинно бути зрозуміло, що деякий тип відношення між цими двома класами може бути встановлений. Якщо не вдаватися до деталей, можна сказати, що кожен співробітник «має» (<code>has-а</code>) соціальний пакет. Для цього можна додати до полів класу <code>Worker</code> поле <code>SocialPackage</code> таким чином:</p>
<pre><code>  protected SocialPackage socPackage;
</code></pre>
<p>Таким чином, ми успішно включили в клас інший об&rsquo;єкт. Проте для надання функціональності об&rsquo;єкту, що включається, зовнішньому світу необхідний делегування. <strong>Делегування</strong> - це просто додавання у клас членів, які використовують функціональність об&rsquo;єкту, що включається. Найпростіший варіант – реалізація властивостей для включеного поля або методів <code>Get</code>, <code>Set</code>.</p>
<h3 id="845-вкладені-визначення-типів">8.4.5. Вкладені визначення типів</h3>
<p>Перш ніж досліджувати останній стовп ООП (поліморфізм), давайте познайомимося з технікою програмування під назвою вкладені типи. У С# можна визначити тип (перерахування, клас, інтерфейс, структуру або делегат) безпосередньо в області класу або структури. В цьому випадку вкладений (або «внутрішній») тип вважається членом класу, в який він вкладений (тобто «зовнішнього класу»), і з точки зору механізму часу виконання ним можна маніпулювати так само, як будь-яким іншим членом (полем, властивістю, методом, подією і т. д.). Синтаксис, що використовується для створення вкладених типів, досить простий. Розглянемо клас <code>SocialPackage</code> як вкладений.</p>
<pre><code>  class Worker
  {
      protected string firstname;   //Ім'я
      protected string lastname;    //Прізвище
      protected double salary;      //Розмір з/п
      protected double bonus;       //Бонус до з/п у % від з/п
      
      public class SocialPackage
      {
          //Сума виплати
          private double socialSum;

          public double SocialSum
          {
            get { return socialSum; }
            set { socialSum = value; }
          }
      }
	    ...
   }
</code></pre>
<p>Хоча цей синтаксис досить наочний, не завжди зрозуміло, навіщо потрібно так робити. Далі представлені аргументи, покликані допомогти в цьому розібратися:</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> Модель вкладених типів схожа на відношення «має» за винятком того, що у вас є повний контроль над рівнем доступу не до об&rsquo;єкту, що включається, а до внутрішнього типу.</li>
<li><input checked="" disabled="" type="checkbox"> Оскільки вкладений тип - це член включеного класу, він може звертатися до закритих членів цього класу.</li>
<li><input checked="" disabled="" type="checkbox"> Частенько вкладений тип корисний лише як допоміжний для класу і не призначений для використання зовнішнім світом.</li>
<li><input checked="" disabled="" type="checkbox"> Коли тип містить інший тип-клас, він може створювати змінні-члени цього типу так само, як і інші елементи даних. Проте, якщо ви хочете використовувати вкладений тип ззовні включаючого типу, тип необхідно кваліфікувати вкладеним типом.</li>
</ul>
<hr>
<h2 id="85-підтримка-поліморфізму-у-c">8.5. Підтримка поліморфізму у C#</h2>
<h3 id="851-реалізація-поліморфізму-у-с">8.5.1. Реалізація поліморфізму у С#</h3>
<p>Тепер давайте дослідимо завершальний стовп ООП - <strong>поліморфізм</strong>.
Реалізуємо у класі <code>Worker</code> метод <code>GiveBonus()</code> таким чином:</p>
<pre><code>  public void GiveBonus(float bon)
  {
    salary += bon;
  }
</code></pre>
<p>Оскільки цей метод був визначений як відкритий, ми можемо надавати бонуси як торгівельним агентам, так і менеджерам (а також торгівельним агентам, що працюють за сумісництвом):</p>
<pre><code>  SalesPerson sPerson = new SalesPerson(&quot;Петро&quot;, &quot;Петров&quot;,125, 0.21, 154);
  Console.WriteLine(&quot;З/п: {0}&quot;, sPerson.Salary);
  Console.WriteLine(&quot;Додамо бонус - 12.5!&quot;);
  sPerson.GiveBonus(12.5f);
  Console.WriteLine(&quot;З/п: {0}&quot;, sPerson.Salary);
</code></pre>
<p>Результат:</p>
<pre><code>  З/п: 125
  Додамо бонус: 12.5!
  З/п: 137.5
</code></pre>
<p>Проблема поточного дизайну полягає в тому, що успадкований метод <code>GiveBonus()</code> працює ідентично для всіх підкласів. У ідеалі в бонусі торгівельного представника або торгівельного представника за сумісництвом повинен враховуватися об&rsquo;єм продажів. Можливо, менеджери повинні отримувати додаткові акції на додаток до збільшення зарплати.</p>
<hr>
<h3 id="852-ключові-слова-virtual-і-override">8.5.2. Ключові слова <code>virtual</code> і <code>override</code></h3>
<p>Поліморфізм надає підкласам можливість зміни реалізації методів, визначених у їх базовому класі. Для зміни поточного дизайну необхідно розуміти значення ключових слів <code>virtual</code> та <code>override</code> мови С#. Якщо у базовому класі визначається метод, який може бути перекритий підкласом, цей метод має бути віртуальним:</p>
<pre><code>  class Worker
  {
    ...
    public virtual void GiveBonus(float bon)
    {
      salary += bon;
    }
  	...
  }
</code></pre>
<p>Коли підкласу потрібно перевизначити віртуальний метод, це робиться за допомогою ключового слова <code>override</code>. Наприклад, типи <code>SalesPerson</code> і <code>Manager</code> можуть перекрити метод <code>GiveBonus()</code> таким чином:</p>
<pre><code>  class SalesPerson : Worker
  {
	  ...
    public override void GiveBonus(float bon)
    {
      if (salesQuantity &gt; 100)
          bon += bon * 0.1f;
      salary += bon;
    }
	  ...
  }
</code></pre>
<p>Зверніть увагу, як кожен перекритий метод може використовувати поведінку за замовчуванням за допомогою ключового слова base. Toбто вам не потрібно повністю повторно реалізовувати логіку методу <code>GiveBonus()</code>, ви можете багато разів задіювати (і, можливо, розширювати) поведінку за замовчуванням батьківського класу.</p>
<p>Наприклад:</p>
<pre><code>  public override void GiveBonus(float bon)
  {
    if (salesQuantity &gt; 100)
        bon += bon * 0.1f;
    base.GiveBonus(bon);
  }
</code></pre>
<hr>
<h3 id="853-поняття-абстрактного-класу">8.5.3. Поняття абстрактного класу</h3>
<p>В даний момент базовий клас Worker надає захищені змінні-члени своїм наслідникам, а також підтримує віртуальний метод (<code>GiveBonus()</code>), який може бути перекритий наслідниками.</p>
<p>Хоча це все і чудово, в поточному дизайні є дивний побічний ефект, що полягає в тому, що ви можете безпосередньо створити екземпляри базового класу <code>Worker</code>:</p>
<pre><code>// Що ж це на справді означає?
Worker worker = new Worker();
</code></pre>
<p>У даному прикладі єдине дійсне призначення базового класу Worker полягає у визначенні загальних полів і членів для всіх підкласів. Зрозуміло, що немає сенсу створювати безпосередній екземпляр цього класу, оскільки тип Worker сам по собі дуже узагальнений. Наприклад, якби я підійшов до вас і сказав: «Я співробітник!», ваше перше питання було б: «Ну і що ти за співробітник?» (консультант, тренер, помічник адміністратора, редактор, співробітник Білого дому і т. д.).</p>
<p>Враховуючи, що багато базових класів є досить туманними сутностями, набагато краще в нашому прикладі було б запобігти можливості безпосереднього створення об&rsquo;єктів класу Worker в коді. У С# це можна зробити програмно, використовуючи ключове слово <code>abstract</code>:</p>
<pre><code>  abstract class Worker
  {
  	// Поля
  	// Методи
  	// Властивості
  }
</code></pre>
<p>Таким чином створити обєкт класу не вдасться.</p>
<hr>
<span style="float:right">

  <i class="fas fa-file-powerpoint fa-2x text-danger  pr-1 fa-fw"></i>
</span>
<h2 id="презентація">Презентація</h2>
<br>
<iframe src="https://onedrive.live.com/embed?cid=0A1340BA71B3F0AA&amp;resid=A1340BA71B3F0AA%213939&amp;authkey=ALTJQw7LlW8LZMk&amp;em=2&amp;wdAr=1.7777777777777777" width="100%" height="400px" frameborder="0">Це вбудований документ <a target="_blank" href="https://office.com">Microsoft Office</a> на платформі <a target="_blank" href="https://office.com/webapps">Office</a>.</iframe>
<hr>
<span style="float:right">

  <i class="fas fa-list-alt fa-2x text-success  pr-1 fa-fw"></i>
</span>
<h2 id="chapter8task">Задачі</h2>
<hr>
<span style="float:right">

  <i class="fas fa-question-circle text-warning fa-2x  pr-1 fa-fw"></i>
</span>
<h2 id="chapter8questions">Контрольні запитання</h2>
<hr>
<span style="float:right">

  <i class="far fa-bookmark text-primary fa-2x  pr-1 fa-fw"></i>
</span>
<h2 id="chapter8sources">Де почитати?</h2>
<p>Книги:</p>
<ol>
<li>
<p>Назва книги</p>
<p>Сторінки: 1254-1284.</p>
</li>
</ol>
<p>Блоги, статті:</p>
<ol>
<li><a href="https://metanit.com/sharp/tutorial/3.29.php" target="_blank" rel="noopener">
  <i class="fas fa-link text-primary  pr-1 fa-fw"></i> Metanit. Объектно-ориентированное программирование. Практика</a> (RU)</li>
<li></li>
</ol>
<p>Відео-контент:</p>
<ul>
<li>
<p><input checked="" disabled="" type="checkbox"> <a href="https://metanit.com/sharp/tutorial/3.29.php" target="_blank" rel="noopener">
  <i class="fab fa-youtube text-danger  pr-1 fa-fw"></i> Metanit. Объектно-ориентированное программирование. Практика</a></p>
</li>
<li>
<p><input checked="" disabled="" type="checkbox"> <a href="https://metanit.com/sharp/tutorial/3.29.php" target="_blank" rel="noopener">
  <i class="fab fa-microsoft text-primary  pr-1 fa-fw"></i> Metanit. Объектно-ориентированное программирование. Практика</a></p>
</li>
</ul>
<hr>
<span style="float:right">

  <i class="fas fa-book text-primary fa-2x  pr-1 fa-fw"></i>
</span>
<h2 id="chapter8sources">Список використаних джерел</h2>
<ol>
<li>Albahari, J., &amp; Albahari, B. (2012). C# 5.0 in a Nutshell, Fifth Edition. 1005 Gravenstein Highway North, Sebastopol, USA: O’Reilly Media, Inc.</li>
<li>Cardelli, L., &amp; Wegner, P. (December 1985 p.). On Understanding Types, Data Abstraction, and Polymorphism. ACM Computing 1. Surveys, 17(4), сс. 149-154. Отримано з <a href="http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf">http://lucacardelli.name/Papers/OnUnderstanding.A4.pdf</a></li>
<li>Kort, W. d. (2013). Exam Ref 70-483: Programming in C#. Sebastopol, California 95472: O’Reilly Media, Inc.</li>
<li>MSDN. (без дати). Отримано з Microsoft Developer Network: <a href="http://msdn.microsoft.com/">http://msdn.microsoft.com/</a></li>
<li>Биллиг, А. (2005). Основы программирования на C#. Москва, Россия: НОУ ИНТУИТ.</li>
<li>Нейгел, К. И. (2011). С# 4.0 и платформа .NET 4 для профессионалов. Москва, Россия: ООО &ldquo;И.Д. Вильямс&rdquo;.</li>
<li>Павловская, Т. (2009). С#. Программирование на языке высокого уровня. Учебник для вузов. СПб, Россия: Питер.</li>
</ol>
<hr>
<span style="float:right">

  <i class="fas fa-download fa-2x  pr-1 fa-fw"></i>
</span>
<h2 id="chapter8additional">Додаткові матеріали для завантаження</h2>
<ol>
<li><del>Лекція у форматі DOCX <a href="">
  <i class="fas fa-file-word  pr-1 fa-fw"></i> Завантажити</a></del> (у розробці)</li>
<li><del>Лекція у форматі PDF <a href="">
  <i class="fas fa-file-pdf  pr-1 fa-fw"></i> Завантажити</a></del> (у розробці)</li>
<li>Діаграми до лекції у форматі <code>
  <i class="fas fa-project-diagram  pr-1 fa-fw"></i>draw.io</code> на <code>
  <i class="fab fa-github  pr-1 fa-fw"></i>github</code> <a href="https://github.com/kleban/csharp-basics-public/tree/master/diagrams" target="_blank" rel="noopener"> Перейти</a></li>
</ol>
<hr>
<div class="alert alert-note">
  <div>
    Дорогі друзі, якщо Ви помітили, що для написання матеріалів використані джерела, які я не вказав - прошу надіслати мені інформацію на пошту.
Дякую.
  </div>
</div>

          </div>

          

<div class="article-tags">
  
  <a class="badge badge-light" href="/tag/csharp/">csharp</a>
  
  <a class="badge badge-light" href="/tag/economic-cybernetics/">economic cybernetics</a>
  
  <a class="badge badge-light" href="/tag/ostroh-academy/">ostroh academy</a>
  
  <a class="badge badge-light" href="/tag/c/">C#</a>
  
  <a class="badge badge-light" href="/tag/visual-studio/">visual studio</a>
  
  <a class="badge badge-light" href="/tag/.net-framework/">.net framework</a>
  
  <a class="badge badge-light" href="/tag/console-application/">console application</a>
  
  <a class="badge badge-light" href="/tag/cts/">CTS</a>
  
  <a class="badge badge-light" href="/tag/value-type/">Value Type</a>
  
  <a class="badge badge-light" href="/tag/reference-type/">Reference Type</a>
  
  <a class="badge badge-light" href="/tag/oop/">OOP</a>
  
  <a class="badge badge-light" href="/tag/object/">Object</a>
  
  <a class="badge badge-light" href="/tag/class/">Class</a>
  
  <a class="badge badge-light" href="/tag/object-oriented-programming/">Object-oriented programming</a>
  
  <a class="badge badge-light" href="/tag/encapsulation/">Encapsulation</a>
  
  <a class="badge badge-light" href="/tag/polimorphism/">Polimorphism</a>
  
</div>



          
          <div class="article-widget">
            
<div class="post-nav">
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Previous</div>
    <a href="/courses/csharp-basics/lecture7/" rel="next">Лекція 7. Перелічувані типи та структури</a>
  </div>
  
  
  
  <div class="post-nav-item">
    <div class="meta-nav">Next</div>
    <a href="/courses/csharp-basics/lecturex/" rel="prev">Лекція X. Додаткові матеріали</a>
  </div>
  
</div>

          </div>
          
        </div>

        <div class="body-footer">
          <p>Last updated on Apr 18, 2021</p>

          





          




          




        </div>

      </article>

      <footer class="site-footer">
  

  <p class="powered-by">
    © 2022 Yurii Kleban
  </p>

  
  






  <p class="powered-by">
    
    
    
    Published with
    <a href="https://wowchemy.com/?utm_campaign=poweredby" target="_blank" rel="noopener">Wowchemy</a>  —
    the free, <a href="https://github.com/wowchemy/wowchemy-hugo-modules" target="_blank" rel="noopener">
    open source</a> website builder that empowers creators.
    
  </p>
</footer>


    </main>
  </div>
</div>

  </div>

  <div class="page-footer">
    
    
  </div>

  
<div id="modal" class="modal fade" role="dialog">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Cite</h5>
        <button type="button" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body">
        <pre><code class="tex hljs"></code></pre>
      </div>
      <div class="modal-footer">
        <a class="btn btn-outline-primary my-1 js-copy-cite" href="#" target="_blank">
          <i class="fas fa-copy"></i> Copy
        </a>
        <a class="btn btn-outline-primary my-1 js-download-cite" href="#" target="_blank">
          <i class="fas fa-download"></i> Download
        </a>
        <div id="modal-error"></div>
      </div>
    </div>
  </div>
</div>

      

    
    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>

      
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.imagesloaded/4.1.4/imagesloaded.pkgd.min.js" integrity="sha256-lqvxZrPLtfffUl2G/e7szqSvPBILGbwmsGE1MKlOi0Q=" crossorigin="anonymous"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.isotope/3.0.6/isotope.pkgd.min.js" integrity="sha256-CBrpuqrMhXwcLLUd5tvQ4euBHCdh7wGlDfNz8vbu/iI=" crossorigin="anonymous"></script>
      

      <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js" integrity="sha256-yt2kYMy0w8AbtF89WXb2P1rfjcP/HTHLT7097U8Y5b8=" crossorigin="anonymous"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/instant.page/5.1.0/instantpage.min.js" integrity="sha512-1+qUtKoh9XZW7j+6LhRMAyOrgSQKenQ4mluTR+cvxXjP1Z54RxZuzstR/H9kgPXQsVB8IW7DMDFUJpzLjvhGSQ==" crossorigin="anonymous"></script>

      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/mermaid/8.8.4/mermaid.min.js" integrity="sha512-as1BF4+iHZ3BVO6LLDQ7zrbvTXM+c/1iZ1qII/c3c4L8Rn5tHLpFUtpaEtBNS92f+xGsCzsD7b62XP3XYap6oA==" crossorigin="anonymous" title="mermaid"></script>
      

      
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js" integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw==" crossorigin="anonymous"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/r.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/python.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/latex.min.js"></script>
        
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/languages/csharp.min.js"></script>
        
      

    

    
    
      <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/leaflet.min.js" integrity="sha512-SeiQaaDh73yrb56sTW/RgVdi/mMqNeM2oBwubFHagc5BkixSpP1fvqF47mKzPGWYSSy4RwbBunrJBQ4Co8fRWA==" crossorigin="anonymous"></script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha512-I7w3ZdSFzw5j3jU3ZkNikBNeIrl3i+hEuEdwNmqUJvwNcaBUNcijnP2gd9DtGlgVYDplfjGoD8vTNsID+lCjqg==" crossorigin="anonymous"></script>
    <script>
      anchors.add();
    </script>
    

    
    
    <script id="search-hit-fuse-template" type="text/x-template">
      <div class="search-hit" id="summary-{{key}}">
        <div class="search-hit-content">
          <div class="search-hit-name">
            <a href="{{relpermalink}}">{{title}}</a>
            <div class="article-metadata search-hit-type">{{type}}</div>
            <p class="search-hit-description">{{snippet}}</p>
          </div>
        </div>
      </div>
    </script>
    

    
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fuse.js/3.2.1/fuse.min.js" integrity="sha256-VzgmKYmhsGNNN4Ph1kMW+BjoYJM2jV5i4IlFoeZA9XI=" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mark.js/8.11.1/jquery.mark.min.js" integrity="sha256-4HLtjeVgH0eIB3aZ9mLYF6E8oU5chNdjU6p6rrXpl9U=" crossorigin="anonymous"></script>
    

    
    
    

    
    
    

    
    

    
    

    
    
      
      
      
      
      
      
      
    

    
    
    
    
    
    
    
    
    
    
      
      
    
    
    <script src="/en/js/wowchemy.min.06e52bf0665167274d459a9300d0fab2.js"></script>

    
  <script async defer src="https://buttons.github.io/buttons.js"></script>




</body>
</html>
